// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"
	"time"

	baseca "github.com/IBM-Blockchain/fabric-operator/pkg/offering/base/ca"
	v1a "k8s.io/api/core/v1"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type CertificateManager struct {
	ExpiresStub        func([]byte, int64) (bool, time.Time, error)
	expiresMutex       sync.RWMutex
	expiresArgsForCall []struct {
		arg1 []byte
		arg2 int64
	}
	expiresReturns struct {
		result1 bool
		result2 time.Time
		result3 error
	}
	expiresReturnsOnCall map[int]struct {
		result1 bool
		result2 time.Time
		result3 error
	}
	GetDurationToNextRenewalForCertStub        func(string, []byte, v1.Object, int64) (time.Duration, error)
	getDurationToNextRenewalForCertMutex       sync.RWMutex
	getDurationToNextRenewalForCertArgsForCall []struct {
		arg1 string
		arg2 []byte
		arg3 v1.Object
		arg4 int64
	}
	getDurationToNextRenewalForCertReturns struct {
		result1 time.Duration
		result2 error
	}
	getDurationToNextRenewalForCertReturnsOnCall map[int]struct {
		result1 time.Duration
		result2 error
	}
	GetSecretStub        func(string, string) (*v1a.Secret, error)
	getSecretMutex       sync.RWMutex
	getSecretArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getSecretReturns struct {
		result1 *v1a.Secret
		result2 error
	}
	getSecretReturnsOnCall map[int]struct {
		result1 *v1a.Secret
		result2 error
	}
	UpdateSecretStub        func(v1.Object, string, map[string][]byte) error
	updateSecretMutex       sync.RWMutex
	updateSecretArgsForCall []struct {
		arg1 v1.Object
		arg2 string
		arg3 map[string][]byte
	}
	updateSecretReturns struct {
		result1 error
	}
	updateSecretReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *CertificateManager) Expires(arg1 []byte, arg2 int64) (bool, time.Time, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.expiresMutex.Lock()
	ret, specificReturn := fake.expiresReturnsOnCall[len(fake.expiresArgsForCall)]
	fake.expiresArgsForCall = append(fake.expiresArgsForCall, struct {
		arg1 []byte
		arg2 int64
	}{arg1Copy, arg2})
	fake.recordInvocation("Expires", []interface{}{arg1Copy, arg2})
	fake.expiresMutex.Unlock()
	if fake.ExpiresStub != nil {
		return fake.ExpiresStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.expiresReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *CertificateManager) ExpiresCallCount() int {
	fake.expiresMutex.RLock()
	defer fake.expiresMutex.RUnlock()
	return len(fake.expiresArgsForCall)
}

func (fake *CertificateManager) ExpiresCalls(stub func([]byte, int64) (bool, time.Time, error)) {
	fake.expiresMutex.Lock()
	defer fake.expiresMutex.Unlock()
	fake.ExpiresStub = stub
}

func (fake *CertificateManager) ExpiresArgsForCall(i int) ([]byte, int64) {
	fake.expiresMutex.RLock()
	defer fake.expiresMutex.RUnlock()
	argsForCall := fake.expiresArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *CertificateManager) ExpiresReturns(result1 bool, result2 time.Time, result3 error) {
	fake.expiresMutex.Lock()
	defer fake.expiresMutex.Unlock()
	fake.ExpiresStub = nil
	fake.expiresReturns = struct {
		result1 bool
		result2 time.Time
		result3 error
	}{result1, result2, result3}
}

func (fake *CertificateManager) ExpiresReturnsOnCall(i int, result1 bool, result2 time.Time, result3 error) {
	fake.expiresMutex.Lock()
	defer fake.expiresMutex.Unlock()
	fake.ExpiresStub = nil
	if fake.expiresReturnsOnCall == nil {
		fake.expiresReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 time.Time
			result3 error
		})
	}
	fake.expiresReturnsOnCall[i] = struct {
		result1 bool
		result2 time.Time
		result3 error
	}{result1, result2, result3}
}

func (fake *CertificateManager) GetDurationToNextRenewalForCert(arg1 string, arg2 []byte, arg3 v1.Object, arg4 int64) (time.Duration, error) {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.getDurationToNextRenewalForCertMutex.Lock()
	ret, specificReturn := fake.getDurationToNextRenewalForCertReturnsOnCall[len(fake.getDurationToNextRenewalForCertArgsForCall)]
	fake.getDurationToNextRenewalForCertArgsForCall = append(fake.getDurationToNextRenewalForCertArgsForCall, struct {
		arg1 string
		arg2 []byte
		arg3 v1.Object
		arg4 int64
	}{arg1, arg2Copy, arg3, arg4})
	fake.recordInvocation("GetDurationToNextRenewalForCert", []interface{}{arg1, arg2Copy, arg3, arg4})
	fake.getDurationToNextRenewalForCertMutex.Unlock()
	if fake.GetDurationToNextRenewalForCertStub != nil {
		return fake.GetDurationToNextRenewalForCertStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getDurationToNextRenewalForCertReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *CertificateManager) GetDurationToNextRenewalForCertCallCount() int {
	fake.getDurationToNextRenewalForCertMutex.RLock()
	defer fake.getDurationToNextRenewalForCertMutex.RUnlock()
	return len(fake.getDurationToNextRenewalForCertArgsForCall)
}

func (fake *CertificateManager) GetDurationToNextRenewalForCertCalls(stub func(string, []byte, v1.Object, int64) (time.Duration, error)) {
	fake.getDurationToNextRenewalForCertMutex.Lock()
	defer fake.getDurationToNextRenewalForCertMutex.Unlock()
	fake.GetDurationToNextRenewalForCertStub = stub
}

func (fake *CertificateManager) GetDurationToNextRenewalForCertArgsForCall(i int) (string, []byte, v1.Object, int64) {
	fake.getDurationToNextRenewalForCertMutex.RLock()
	defer fake.getDurationToNextRenewalForCertMutex.RUnlock()
	argsForCall := fake.getDurationToNextRenewalForCertArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *CertificateManager) GetDurationToNextRenewalForCertReturns(result1 time.Duration, result2 error) {
	fake.getDurationToNextRenewalForCertMutex.Lock()
	defer fake.getDurationToNextRenewalForCertMutex.Unlock()
	fake.GetDurationToNextRenewalForCertStub = nil
	fake.getDurationToNextRenewalForCertReturns = struct {
		result1 time.Duration
		result2 error
	}{result1, result2}
}

func (fake *CertificateManager) GetDurationToNextRenewalForCertReturnsOnCall(i int, result1 time.Duration, result2 error) {
	fake.getDurationToNextRenewalForCertMutex.Lock()
	defer fake.getDurationToNextRenewalForCertMutex.Unlock()
	fake.GetDurationToNextRenewalForCertStub = nil
	if fake.getDurationToNextRenewalForCertReturnsOnCall == nil {
		fake.getDurationToNextRenewalForCertReturnsOnCall = make(map[int]struct {
			result1 time.Duration
			result2 error
		})
	}
	fake.getDurationToNextRenewalForCertReturnsOnCall[i] = struct {
		result1 time.Duration
		result2 error
	}{result1, result2}
}

func (fake *CertificateManager) GetSecret(arg1 string, arg2 string) (*v1a.Secret, error) {
	fake.getSecretMutex.Lock()
	ret, specificReturn := fake.getSecretReturnsOnCall[len(fake.getSecretArgsForCall)]
	fake.getSecretArgsForCall = append(fake.getSecretArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetSecret", []interface{}{arg1, arg2})
	fake.getSecretMutex.Unlock()
	if fake.GetSecretStub != nil {
		return fake.GetSecretStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getSecretReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *CertificateManager) GetSecretCallCount() int {
	fake.getSecretMutex.RLock()
	defer fake.getSecretMutex.RUnlock()
	return len(fake.getSecretArgsForCall)
}

func (fake *CertificateManager) GetSecretCalls(stub func(string, string) (*v1a.Secret, error)) {
	fake.getSecretMutex.Lock()
	defer fake.getSecretMutex.Unlock()
	fake.GetSecretStub = stub
}

func (fake *CertificateManager) GetSecretArgsForCall(i int) (string, string) {
	fake.getSecretMutex.RLock()
	defer fake.getSecretMutex.RUnlock()
	argsForCall := fake.getSecretArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *CertificateManager) GetSecretReturns(result1 *v1a.Secret, result2 error) {
	fake.getSecretMutex.Lock()
	defer fake.getSecretMutex.Unlock()
	fake.GetSecretStub = nil
	fake.getSecretReturns = struct {
		result1 *v1a.Secret
		result2 error
	}{result1, result2}
}

func (fake *CertificateManager) GetSecretReturnsOnCall(i int, result1 *v1a.Secret, result2 error) {
	fake.getSecretMutex.Lock()
	defer fake.getSecretMutex.Unlock()
	fake.GetSecretStub = nil
	if fake.getSecretReturnsOnCall == nil {
		fake.getSecretReturnsOnCall = make(map[int]struct {
			result1 *v1a.Secret
			result2 error
		})
	}
	fake.getSecretReturnsOnCall[i] = struct {
		result1 *v1a.Secret
		result2 error
	}{result1, result2}
}

func (fake *CertificateManager) UpdateSecret(arg1 v1.Object, arg2 string, arg3 map[string][]byte) error {
	fake.updateSecretMutex.Lock()
	ret, specificReturn := fake.updateSecretReturnsOnCall[len(fake.updateSecretArgsForCall)]
	fake.updateSecretArgsForCall = append(fake.updateSecretArgsForCall, struct {
		arg1 v1.Object
		arg2 string
		arg3 map[string][]byte
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdateSecret", []interface{}{arg1, arg2, arg3})
	fake.updateSecretMutex.Unlock()
	if fake.UpdateSecretStub != nil {
		return fake.UpdateSecretStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateSecretReturns
	return fakeReturns.result1
}

func (fake *CertificateManager) UpdateSecretCallCount() int {
	fake.updateSecretMutex.RLock()
	defer fake.updateSecretMutex.RUnlock()
	return len(fake.updateSecretArgsForCall)
}

func (fake *CertificateManager) UpdateSecretCalls(stub func(v1.Object, string, map[string][]byte) error) {
	fake.updateSecretMutex.Lock()
	defer fake.updateSecretMutex.Unlock()
	fake.UpdateSecretStub = stub
}

func (fake *CertificateManager) UpdateSecretArgsForCall(i int) (v1.Object, string, map[string][]byte) {
	fake.updateSecretMutex.RLock()
	defer fake.updateSecretMutex.RUnlock()
	argsForCall := fake.updateSecretArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *CertificateManager) UpdateSecretReturns(result1 error) {
	fake.updateSecretMutex.Lock()
	defer fake.updateSecretMutex.Unlock()
	fake.UpdateSecretStub = nil
	fake.updateSecretReturns = struct {
		result1 error
	}{result1}
}

func (fake *CertificateManager) UpdateSecretReturnsOnCall(i int, result1 error) {
	fake.updateSecretMutex.Lock()
	defer fake.updateSecretMutex.Unlock()
	fake.UpdateSecretStub = nil
	if fake.updateSecretReturnsOnCall == nil {
		fake.updateSecretReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateSecretReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *CertificateManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.expiresMutex.RLock()
	defer fake.expiresMutex.RUnlock()
	fake.getDurationToNextRenewalForCertMutex.RLock()
	defer fake.getDurationToNextRenewalForCertMutex.RUnlock()
	fake.getSecretMutex.RLock()
	defer fake.getSecretMutex.RUnlock()
	fake.updateSecretMutex.RLock()
	defer fake.updateSecretMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *CertificateManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ baseca.CertificateManager = new(CertificateManager)
