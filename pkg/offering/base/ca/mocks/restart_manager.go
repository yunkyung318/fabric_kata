// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	baseca "github.com/IBM-Blockchain/fabric-operator/pkg/offering/base/ca"
	"github.com/IBM-Blockchain/fabric-operator/pkg/restart"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type RestartManager struct {
	ForConfigOverrideStub        func(v1.Object) error
	forConfigOverrideMutex       sync.RWMutex
	forConfigOverrideArgsForCall []struct {
		arg1 v1.Object
	}
	forConfigOverrideReturns struct {
		result1 error
	}
	forConfigOverrideReturnsOnCall map[int]struct {
		result1 error
	}
	ForRestartActionStub        func(v1.Object) error
	forRestartActionMutex       sync.RWMutex
	forRestartActionArgsForCall []struct {
		arg1 v1.Object
	}
	forRestartActionReturns struct {
		result1 error
	}
	forRestartActionReturnsOnCall map[int]struct {
		result1 error
	}
	ForTLSReenrollStub        func(v1.Object) error
	forTLSReenrollMutex       sync.RWMutex
	forTLSReenrollArgsForCall []struct {
		arg1 v1.Object
	}
	forTLSReenrollReturns struct {
		result1 error
	}
	forTLSReenrollReturnsOnCall map[int]struct {
		result1 error
	}
	TriggerIfNeededStub        func(restart.Instance) error
	triggerIfNeededMutex       sync.RWMutex
	triggerIfNeededArgsForCall []struct {
		arg1 restart.Instance
	}
	triggerIfNeededReturns struct {
		result1 error
	}
	triggerIfNeededReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *RestartManager) ForConfigOverride(arg1 v1.Object) error {
	fake.forConfigOverrideMutex.Lock()
	ret, specificReturn := fake.forConfigOverrideReturnsOnCall[len(fake.forConfigOverrideArgsForCall)]
	fake.forConfigOverrideArgsForCall = append(fake.forConfigOverrideArgsForCall, struct {
		arg1 v1.Object
	}{arg1})
	fake.recordInvocation("ForConfigOverride", []interface{}{arg1})
	fake.forConfigOverrideMutex.Unlock()
	if fake.ForConfigOverrideStub != nil {
		return fake.ForConfigOverrideStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.forConfigOverrideReturns
	return fakeReturns.result1
}

func (fake *RestartManager) ForConfigOverrideCallCount() int {
	fake.forConfigOverrideMutex.RLock()
	defer fake.forConfigOverrideMutex.RUnlock()
	return len(fake.forConfigOverrideArgsForCall)
}

func (fake *RestartManager) ForConfigOverrideCalls(stub func(v1.Object) error) {
	fake.forConfigOverrideMutex.Lock()
	defer fake.forConfigOverrideMutex.Unlock()
	fake.ForConfigOverrideStub = stub
}

func (fake *RestartManager) ForConfigOverrideArgsForCall(i int) v1.Object {
	fake.forConfigOverrideMutex.RLock()
	defer fake.forConfigOverrideMutex.RUnlock()
	argsForCall := fake.forConfigOverrideArgsForCall[i]
	return argsForCall.arg1
}

func (fake *RestartManager) ForConfigOverrideReturns(result1 error) {
	fake.forConfigOverrideMutex.Lock()
	defer fake.forConfigOverrideMutex.Unlock()
	fake.ForConfigOverrideStub = nil
	fake.forConfigOverrideReturns = struct {
		result1 error
	}{result1}
}

func (fake *RestartManager) ForConfigOverrideReturnsOnCall(i int, result1 error) {
	fake.forConfigOverrideMutex.Lock()
	defer fake.forConfigOverrideMutex.Unlock()
	fake.ForConfigOverrideStub = nil
	if fake.forConfigOverrideReturnsOnCall == nil {
		fake.forConfigOverrideReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.forConfigOverrideReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RestartManager) ForRestartAction(arg1 v1.Object) error {
	fake.forRestartActionMutex.Lock()
	ret, specificReturn := fake.forRestartActionReturnsOnCall[len(fake.forRestartActionArgsForCall)]
	fake.forRestartActionArgsForCall = append(fake.forRestartActionArgsForCall, struct {
		arg1 v1.Object
	}{arg1})
	fake.recordInvocation("ForRestartAction", []interface{}{arg1})
	fake.forRestartActionMutex.Unlock()
	if fake.ForRestartActionStub != nil {
		return fake.ForRestartActionStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.forRestartActionReturns
	return fakeReturns.result1
}

func (fake *RestartManager) ForRestartActionCallCount() int {
	fake.forRestartActionMutex.RLock()
	defer fake.forRestartActionMutex.RUnlock()
	return len(fake.forRestartActionArgsForCall)
}

func (fake *RestartManager) ForRestartActionCalls(stub func(v1.Object) error) {
	fake.forRestartActionMutex.Lock()
	defer fake.forRestartActionMutex.Unlock()
	fake.ForRestartActionStub = stub
}

func (fake *RestartManager) ForRestartActionArgsForCall(i int) v1.Object {
	fake.forRestartActionMutex.RLock()
	defer fake.forRestartActionMutex.RUnlock()
	argsForCall := fake.forRestartActionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *RestartManager) ForRestartActionReturns(result1 error) {
	fake.forRestartActionMutex.Lock()
	defer fake.forRestartActionMutex.Unlock()
	fake.ForRestartActionStub = nil
	fake.forRestartActionReturns = struct {
		result1 error
	}{result1}
}

func (fake *RestartManager) ForRestartActionReturnsOnCall(i int, result1 error) {
	fake.forRestartActionMutex.Lock()
	defer fake.forRestartActionMutex.Unlock()
	fake.ForRestartActionStub = nil
	if fake.forRestartActionReturnsOnCall == nil {
		fake.forRestartActionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.forRestartActionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RestartManager) ForTLSReenroll(arg1 v1.Object) error {
	fake.forTLSReenrollMutex.Lock()
	ret, specificReturn := fake.forTLSReenrollReturnsOnCall[len(fake.forTLSReenrollArgsForCall)]
	fake.forTLSReenrollArgsForCall = append(fake.forTLSReenrollArgsForCall, struct {
		arg1 v1.Object
	}{arg1})
	fake.recordInvocation("ForTLSReenroll", []interface{}{arg1})
	fake.forTLSReenrollMutex.Unlock()
	if fake.ForTLSReenrollStub != nil {
		return fake.ForTLSReenrollStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.forTLSReenrollReturns
	return fakeReturns.result1
}

func (fake *RestartManager) ForTLSReenrollCallCount() int {
	fake.forTLSReenrollMutex.RLock()
	defer fake.forTLSReenrollMutex.RUnlock()
	return len(fake.forTLSReenrollArgsForCall)
}

func (fake *RestartManager) ForTLSReenrollCalls(stub func(v1.Object) error) {
	fake.forTLSReenrollMutex.Lock()
	defer fake.forTLSReenrollMutex.Unlock()
	fake.ForTLSReenrollStub = stub
}

func (fake *RestartManager) ForTLSReenrollArgsForCall(i int) v1.Object {
	fake.forTLSReenrollMutex.RLock()
	defer fake.forTLSReenrollMutex.RUnlock()
	argsForCall := fake.forTLSReenrollArgsForCall[i]
	return argsForCall.arg1
}

func (fake *RestartManager) ForTLSReenrollReturns(result1 error) {
	fake.forTLSReenrollMutex.Lock()
	defer fake.forTLSReenrollMutex.Unlock()
	fake.ForTLSReenrollStub = nil
	fake.forTLSReenrollReturns = struct {
		result1 error
	}{result1}
}

func (fake *RestartManager) ForTLSReenrollReturnsOnCall(i int, result1 error) {
	fake.forTLSReenrollMutex.Lock()
	defer fake.forTLSReenrollMutex.Unlock()
	fake.ForTLSReenrollStub = nil
	if fake.forTLSReenrollReturnsOnCall == nil {
		fake.forTLSReenrollReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.forTLSReenrollReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RestartManager) TriggerIfNeeded(arg1 restart.Instance) error {
	fake.triggerIfNeededMutex.Lock()
	ret, specificReturn := fake.triggerIfNeededReturnsOnCall[len(fake.triggerIfNeededArgsForCall)]
	fake.triggerIfNeededArgsForCall = append(fake.triggerIfNeededArgsForCall, struct {
		arg1 restart.Instance
	}{arg1})
	fake.recordInvocation("TriggerIfNeeded", []interface{}{arg1})
	fake.triggerIfNeededMutex.Unlock()
	if fake.TriggerIfNeededStub != nil {
		return fake.TriggerIfNeededStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.triggerIfNeededReturns
	return fakeReturns.result1
}

func (fake *RestartManager) TriggerIfNeededCallCount() int {
	fake.triggerIfNeededMutex.RLock()
	defer fake.triggerIfNeededMutex.RUnlock()
	return len(fake.triggerIfNeededArgsForCall)
}

func (fake *RestartManager) TriggerIfNeededCalls(stub func(restart.Instance) error) {
	fake.triggerIfNeededMutex.Lock()
	defer fake.triggerIfNeededMutex.Unlock()
	fake.TriggerIfNeededStub = stub
}

func (fake *RestartManager) TriggerIfNeededArgsForCall(i int) restart.Instance {
	fake.triggerIfNeededMutex.RLock()
	defer fake.triggerIfNeededMutex.RUnlock()
	argsForCall := fake.triggerIfNeededArgsForCall[i]
	return argsForCall.arg1
}

func (fake *RestartManager) TriggerIfNeededReturns(result1 error) {
	fake.triggerIfNeededMutex.Lock()
	defer fake.triggerIfNeededMutex.Unlock()
	fake.TriggerIfNeededStub = nil
	fake.triggerIfNeededReturns = struct {
		result1 error
	}{result1}
}

func (fake *RestartManager) TriggerIfNeededReturnsOnCall(i int, result1 error) {
	fake.triggerIfNeededMutex.Lock()
	defer fake.triggerIfNeededMutex.Unlock()
	fake.TriggerIfNeededStub = nil
	if fake.triggerIfNeededReturnsOnCall == nil {
		fake.triggerIfNeededReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.triggerIfNeededReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RestartManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.forConfigOverrideMutex.RLock()
	defer fake.forConfigOverrideMutex.RUnlock()
	fake.forRestartActionMutex.RLock()
	defer fake.forRestartActionMutex.RUnlock()
	fake.forTLSReenrollMutex.RLock()
	defer fake.forTLSReenrollMutex.RUnlock()
	fake.triggerIfNeededMutex.RLock()
	defer fake.triggerIfNeededMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *RestartManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ baseca.RestartManager = new(RestartManager)
