// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	baseca "github.com/IBM-Blockchain/fabric-operator/pkg/offering/base/ca"
)

type Update struct {
	CACryptoCreatedStub        func() bool
	cACryptoCreatedMutex       sync.RWMutex
	cACryptoCreatedArgsForCall []struct {
	}
	cACryptoCreatedReturns struct {
		result1 bool
	}
	cACryptoCreatedReturnsOnCall map[int]struct {
		result1 bool
	}
	CACryptoUpdatedStub        func() bool
	cACryptoUpdatedMutex       sync.RWMutex
	cACryptoUpdatedArgsForCall []struct {
	}
	cACryptoUpdatedReturns struct {
		result1 bool
	}
	cACryptoUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	CAOverridesUpdatedStub        func() bool
	cAOverridesUpdatedMutex       sync.RWMutex
	cAOverridesUpdatedArgsForCall []struct {
	}
	cAOverridesUpdatedReturns struct {
		result1 bool
	}
	cAOverridesUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	CATagUpdatedStub        func() bool
	cATagUpdatedMutex       sync.RWMutex
	cATagUpdatedArgsForCall []struct {
	}
	cATagUpdatedReturns struct {
		result1 bool
	}
	cATagUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	ConfigOverridesUpdatedStub        func() bool
	configOverridesUpdatedMutex       sync.RWMutex
	configOverridesUpdatedArgsForCall []struct {
	}
	configOverridesUpdatedReturns struct {
		result1 bool
	}
	configOverridesUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	FabricVersionUpdatedStub        func() bool
	fabricVersionUpdatedMutex       sync.RWMutex
	fabricVersionUpdatedArgsForCall []struct {
	}
	fabricVersionUpdatedReturns struct {
		result1 bool
	}
	fabricVersionUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	ImagesUpdatedStub        func() bool
	imagesUpdatedMutex       sync.RWMutex
	imagesUpdatedArgsForCall []struct {
	}
	imagesUpdatedReturns struct {
		result1 bool
	}
	imagesUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	RenewTLSCertStub        func() bool
	renewTLSCertMutex       sync.RWMutex
	renewTLSCertArgsForCall []struct {
	}
	renewTLSCertReturns struct {
		result1 bool
	}
	renewTLSCertReturnsOnCall map[int]struct {
		result1 bool
	}
	RestartNeededStub        func() bool
	restartNeededMutex       sync.RWMutex
	restartNeededArgsForCall []struct {
	}
	restartNeededReturns struct {
		result1 bool
	}
	restartNeededReturnsOnCall map[int]struct {
		result1 bool
	}
	SpecUpdatedStub        func() bool
	specUpdatedMutex       sync.RWMutex
	specUpdatedArgsForCall []struct {
	}
	specUpdatedReturns struct {
		result1 bool
	}
	specUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	TLSCAOverridesUpdatedStub        func() bool
	tLSCAOverridesUpdatedMutex       sync.RWMutex
	tLSCAOverridesUpdatedArgsForCall []struct {
	}
	tLSCAOverridesUpdatedReturns struct {
		result1 bool
	}
	tLSCAOverridesUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Update) CACryptoCreated() bool {
	fake.cACryptoCreatedMutex.Lock()
	ret, specificReturn := fake.cACryptoCreatedReturnsOnCall[len(fake.cACryptoCreatedArgsForCall)]
	fake.cACryptoCreatedArgsForCall = append(fake.cACryptoCreatedArgsForCall, struct {
	}{})
	fake.recordInvocation("CACryptoCreated", []interface{}{})
	fake.cACryptoCreatedMutex.Unlock()
	if fake.CACryptoCreatedStub != nil {
		return fake.CACryptoCreatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cACryptoCreatedReturns
	return fakeReturns.result1
}

func (fake *Update) CACryptoCreatedCallCount() int {
	fake.cACryptoCreatedMutex.RLock()
	defer fake.cACryptoCreatedMutex.RUnlock()
	return len(fake.cACryptoCreatedArgsForCall)
}

func (fake *Update) CACryptoCreatedCalls(stub func() bool) {
	fake.cACryptoCreatedMutex.Lock()
	defer fake.cACryptoCreatedMutex.Unlock()
	fake.CACryptoCreatedStub = stub
}

func (fake *Update) CACryptoCreatedReturns(result1 bool) {
	fake.cACryptoCreatedMutex.Lock()
	defer fake.cACryptoCreatedMutex.Unlock()
	fake.CACryptoCreatedStub = nil
	fake.cACryptoCreatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) CACryptoCreatedReturnsOnCall(i int, result1 bool) {
	fake.cACryptoCreatedMutex.Lock()
	defer fake.cACryptoCreatedMutex.Unlock()
	fake.CACryptoCreatedStub = nil
	if fake.cACryptoCreatedReturnsOnCall == nil {
		fake.cACryptoCreatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.cACryptoCreatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) CACryptoUpdated() bool {
	fake.cACryptoUpdatedMutex.Lock()
	ret, specificReturn := fake.cACryptoUpdatedReturnsOnCall[len(fake.cACryptoUpdatedArgsForCall)]
	fake.cACryptoUpdatedArgsForCall = append(fake.cACryptoUpdatedArgsForCall, struct {
	}{})
	fake.recordInvocation("CACryptoUpdated", []interface{}{})
	fake.cACryptoUpdatedMutex.Unlock()
	if fake.CACryptoUpdatedStub != nil {
		return fake.CACryptoUpdatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cACryptoUpdatedReturns
	return fakeReturns.result1
}

func (fake *Update) CACryptoUpdatedCallCount() int {
	fake.cACryptoUpdatedMutex.RLock()
	defer fake.cACryptoUpdatedMutex.RUnlock()
	return len(fake.cACryptoUpdatedArgsForCall)
}

func (fake *Update) CACryptoUpdatedCalls(stub func() bool) {
	fake.cACryptoUpdatedMutex.Lock()
	defer fake.cACryptoUpdatedMutex.Unlock()
	fake.CACryptoUpdatedStub = stub
}

func (fake *Update) CACryptoUpdatedReturns(result1 bool) {
	fake.cACryptoUpdatedMutex.Lock()
	defer fake.cACryptoUpdatedMutex.Unlock()
	fake.CACryptoUpdatedStub = nil
	fake.cACryptoUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) CACryptoUpdatedReturnsOnCall(i int, result1 bool) {
	fake.cACryptoUpdatedMutex.Lock()
	defer fake.cACryptoUpdatedMutex.Unlock()
	fake.CACryptoUpdatedStub = nil
	if fake.cACryptoUpdatedReturnsOnCall == nil {
		fake.cACryptoUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.cACryptoUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) CAOverridesUpdated() bool {
	fake.cAOverridesUpdatedMutex.Lock()
	ret, specificReturn := fake.cAOverridesUpdatedReturnsOnCall[len(fake.cAOverridesUpdatedArgsForCall)]
	fake.cAOverridesUpdatedArgsForCall = append(fake.cAOverridesUpdatedArgsForCall, struct {
	}{})
	fake.recordInvocation("CAOverridesUpdated", []interface{}{})
	fake.cAOverridesUpdatedMutex.Unlock()
	if fake.CAOverridesUpdatedStub != nil {
		return fake.CAOverridesUpdatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cAOverridesUpdatedReturns
	return fakeReturns.result1
}

func (fake *Update) CAOverridesUpdatedCallCount() int {
	fake.cAOverridesUpdatedMutex.RLock()
	defer fake.cAOverridesUpdatedMutex.RUnlock()
	return len(fake.cAOverridesUpdatedArgsForCall)
}

func (fake *Update) CAOverridesUpdatedCalls(stub func() bool) {
	fake.cAOverridesUpdatedMutex.Lock()
	defer fake.cAOverridesUpdatedMutex.Unlock()
	fake.CAOverridesUpdatedStub = stub
}

func (fake *Update) CAOverridesUpdatedReturns(result1 bool) {
	fake.cAOverridesUpdatedMutex.Lock()
	defer fake.cAOverridesUpdatedMutex.Unlock()
	fake.CAOverridesUpdatedStub = nil
	fake.cAOverridesUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) CAOverridesUpdatedReturnsOnCall(i int, result1 bool) {
	fake.cAOverridesUpdatedMutex.Lock()
	defer fake.cAOverridesUpdatedMutex.Unlock()
	fake.CAOverridesUpdatedStub = nil
	if fake.cAOverridesUpdatedReturnsOnCall == nil {
		fake.cAOverridesUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.cAOverridesUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) CATagUpdated() bool {
	fake.cATagUpdatedMutex.Lock()
	ret, specificReturn := fake.cATagUpdatedReturnsOnCall[len(fake.cATagUpdatedArgsForCall)]
	fake.cATagUpdatedArgsForCall = append(fake.cATagUpdatedArgsForCall, struct {
	}{})
	fake.recordInvocation("CATagUpdated", []interface{}{})
	fake.cATagUpdatedMutex.Unlock()
	if fake.CATagUpdatedStub != nil {
		return fake.CATagUpdatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cATagUpdatedReturns
	return fakeReturns.result1
}

func (fake *Update) CATagUpdatedCallCount() int {
	fake.cATagUpdatedMutex.RLock()
	defer fake.cATagUpdatedMutex.RUnlock()
	return len(fake.cATagUpdatedArgsForCall)
}

func (fake *Update) CATagUpdatedCalls(stub func() bool) {
	fake.cATagUpdatedMutex.Lock()
	defer fake.cATagUpdatedMutex.Unlock()
	fake.CATagUpdatedStub = stub
}

func (fake *Update) CATagUpdatedReturns(result1 bool) {
	fake.cATagUpdatedMutex.Lock()
	defer fake.cATagUpdatedMutex.Unlock()
	fake.CATagUpdatedStub = nil
	fake.cATagUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) CATagUpdatedReturnsOnCall(i int, result1 bool) {
	fake.cATagUpdatedMutex.Lock()
	defer fake.cATagUpdatedMutex.Unlock()
	fake.CATagUpdatedStub = nil
	if fake.cATagUpdatedReturnsOnCall == nil {
		fake.cATagUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.cATagUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) ConfigOverridesUpdated() bool {
	fake.configOverridesUpdatedMutex.Lock()
	ret, specificReturn := fake.configOverridesUpdatedReturnsOnCall[len(fake.configOverridesUpdatedArgsForCall)]
	fake.configOverridesUpdatedArgsForCall = append(fake.configOverridesUpdatedArgsForCall, struct {
	}{})
	fake.recordInvocation("ConfigOverridesUpdated", []interface{}{})
	fake.configOverridesUpdatedMutex.Unlock()
	if fake.ConfigOverridesUpdatedStub != nil {
		return fake.ConfigOverridesUpdatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.configOverridesUpdatedReturns
	return fakeReturns.result1
}

func (fake *Update) ConfigOverridesUpdatedCallCount() int {
	fake.configOverridesUpdatedMutex.RLock()
	defer fake.configOverridesUpdatedMutex.RUnlock()
	return len(fake.configOverridesUpdatedArgsForCall)
}

func (fake *Update) ConfigOverridesUpdatedCalls(stub func() bool) {
	fake.configOverridesUpdatedMutex.Lock()
	defer fake.configOverridesUpdatedMutex.Unlock()
	fake.ConfigOverridesUpdatedStub = stub
}

func (fake *Update) ConfigOverridesUpdatedReturns(result1 bool) {
	fake.configOverridesUpdatedMutex.Lock()
	defer fake.configOverridesUpdatedMutex.Unlock()
	fake.ConfigOverridesUpdatedStub = nil
	fake.configOverridesUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) ConfigOverridesUpdatedReturnsOnCall(i int, result1 bool) {
	fake.configOverridesUpdatedMutex.Lock()
	defer fake.configOverridesUpdatedMutex.Unlock()
	fake.ConfigOverridesUpdatedStub = nil
	if fake.configOverridesUpdatedReturnsOnCall == nil {
		fake.configOverridesUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.configOverridesUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) FabricVersionUpdated() bool {
	fake.fabricVersionUpdatedMutex.Lock()
	ret, specificReturn := fake.fabricVersionUpdatedReturnsOnCall[len(fake.fabricVersionUpdatedArgsForCall)]
	fake.fabricVersionUpdatedArgsForCall = append(fake.fabricVersionUpdatedArgsForCall, struct {
	}{})
	fake.recordInvocation("FabricVersionUpdated", []interface{}{})
	fake.fabricVersionUpdatedMutex.Unlock()
	if fake.FabricVersionUpdatedStub != nil {
		return fake.FabricVersionUpdatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.fabricVersionUpdatedReturns
	return fakeReturns.result1
}

func (fake *Update) FabricVersionUpdatedCallCount() int {
	fake.fabricVersionUpdatedMutex.RLock()
	defer fake.fabricVersionUpdatedMutex.RUnlock()
	return len(fake.fabricVersionUpdatedArgsForCall)
}

func (fake *Update) FabricVersionUpdatedCalls(stub func() bool) {
	fake.fabricVersionUpdatedMutex.Lock()
	defer fake.fabricVersionUpdatedMutex.Unlock()
	fake.FabricVersionUpdatedStub = stub
}

func (fake *Update) FabricVersionUpdatedReturns(result1 bool) {
	fake.fabricVersionUpdatedMutex.Lock()
	defer fake.fabricVersionUpdatedMutex.Unlock()
	fake.FabricVersionUpdatedStub = nil
	fake.fabricVersionUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) FabricVersionUpdatedReturnsOnCall(i int, result1 bool) {
	fake.fabricVersionUpdatedMutex.Lock()
	defer fake.fabricVersionUpdatedMutex.Unlock()
	fake.FabricVersionUpdatedStub = nil
	if fake.fabricVersionUpdatedReturnsOnCall == nil {
		fake.fabricVersionUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.fabricVersionUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) ImagesUpdated() bool {
	fake.imagesUpdatedMutex.Lock()
	ret, specificReturn := fake.imagesUpdatedReturnsOnCall[len(fake.imagesUpdatedArgsForCall)]
	fake.imagesUpdatedArgsForCall = append(fake.imagesUpdatedArgsForCall, struct {
	}{})
	fake.recordInvocation("ImagesUpdated", []interface{}{})
	fake.imagesUpdatedMutex.Unlock()
	if fake.ImagesUpdatedStub != nil {
		return fake.ImagesUpdatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.imagesUpdatedReturns
	return fakeReturns.result1
}

func (fake *Update) ImagesUpdatedCallCount() int {
	fake.imagesUpdatedMutex.RLock()
	defer fake.imagesUpdatedMutex.RUnlock()
	return len(fake.imagesUpdatedArgsForCall)
}

func (fake *Update) ImagesUpdatedCalls(stub func() bool) {
	fake.imagesUpdatedMutex.Lock()
	defer fake.imagesUpdatedMutex.Unlock()
	fake.ImagesUpdatedStub = stub
}

func (fake *Update) ImagesUpdatedReturns(result1 bool) {
	fake.imagesUpdatedMutex.Lock()
	defer fake.imagesUpdatedMutex.Unlock()
	fake.ImagesUpdatedStub = nil
	fake.imagesUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) ImagesUpdatedReturnsOnCall(i int, result1 bool) {
	fake.imagesUpdatedMutex.Lock()
	defer fake.imagesUpdatedMutex.Unlock()
	fake.ImagesUpdatedStub = nil
	if fake.imagesUpdatedReturnsOnCall == nil {
		fake.imagesUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.imagesUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) RenewTLSCert() bool {
	fake.renewTLSCertMutex.Lock()
	ret, specificReturn := fake.renewTLSCertReturnsOnCall[len(fake.renewTLSCertArgsForCall)]
	fake.renewTLSCertArgsForCall = append(fake.renewTLSCertArgsForCall, struct {
	}{})
	fake.recordInvocation("RenewTLSCert", []interface{}{})
	fake.renewTLSCertMutex.Unlock()
	if fake.RenewTLSCertStub != nil {
		return fake.RenewTLSCertStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renewTLSCertReturns
	return fakeReturns.result1
}

func (fake *Update) RenewTLSCertCallCount() int {
	fake.renewTLSCertMutex.RLock()
	defer fake.renewTLSCertMutex.RUnlock()
	return len(fake.renewTLSCertArgsForCall)
}

func (fake *Update) RenewTLSCertCalls(stub func() bool) {
	fake.renewTLSCertMutex.Lock()
	defer fake.renewTLSCertMutex.Unlock()
	fake.RenewTLSCertStub = stub
}

func (fake *Update) RenewTLSCertReturns(result1 bool) {
	fake.renewTLSCertMutex.Lock()
	defer fake.renewTLSCertMutex.Unlock()
	fake.RenewTLSCertStub = nil
	fake.renewTLSCertReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) RenewTLSCertReturnsOnCall(i int, result1 bool) {
	fake.renewTLSCertMutex.Lock()
	defer fake.renewTLSCertMutex.Unlock()
	fake.RenewTLSCertStub = nil
	if fake.renewTLSCertReturnsOnCall == nil {
		fake.renewTLSCertReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.renewTLSCertReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) RestartNeeded() bool {
	fake.restartNeededMutex.Lock()
	ret, specificReturn := fake.restartNeededReturnsOnCall[len(fake.restartNeededArgsForCall)]
	fake.restartNeededArgsForCall = append(fake.restartNeededArgsForCall, struct {
	}{})
	fake.recordInvocation("RestartNeeded", []interface{}{})
	fake.restartNeededMutex.Unlock()
	if fake.RestartNeededStub != nil {
		return fake.RestartNeededStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.restartNeededReturns
	return fakeReturns.result1
}

func (fake *Update) RestartNeededCallCount() int {
	fake.restartNeededMutex.RLock()
	defer fake.restartNeededMutex.RUnlock()
	return len(fake.restartNeededArgsForCall)
}

func (fake *Update) RestartNeededCalls(stub func() bool) {
	fake.restartNeededMutex.Lock()
	defer fake.restartNeededMutex.Unlock()
	fake.RestartNeededStub = stub
}

func (fake *Update) RestartNeededReturns(result1 bool) {
	fake.restartNeededMutex.Lock()
	defer fake.restartNeededMutex.Unlock()
	fake.RestartNeededStub = nil
	fake.restartNeededReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) RestartNeededReturnsOnCall(i int, result1 bool) {
	fake.restartNeededMutex.Lock()
	defer fake.restartNeededMutex.Unlock()
	fake.RestartNeededStub = nil
	if fake.restartNeededReturnsOnCall == nil {
		fake.restartNeededReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.restartNeededReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) SpecUpdated() bool {
	fake.specUpdatedMutex.Lock()
	ret, specificReturn := fake.specUpdatedReturnsOnCall[len(fake.specUpdatedArgsForCall)]
	fake.specUpdatedArgsForCall = append(fake.specUpdatedArgsForCall, struct {
	}{})
	fake.recordInvocation("SpecUpdated", []interface{}{})
	fake.specUpdatedMutex.Unlock()
	if fake.SpecUpdatedStub != nil {
		return fake.SpecUpdatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.specUpdatedReturns
	return fakeReturns.result1
}

func (fake *Update) SpecUpdatedCallCount() int {
	fake.specUpdatedMutex.RLock()
	defer fake.specUpdatedMutex.RUnlock()
	return len(fake.specUpdatedArgsForCall)
}

func (fake *Update) SpecUpdatedCalls(stub func() bool) {
	fake.specUpdatedMutex.Lock()
	defer fake.specUpdatedMutex.Unlock()
	fake.SpecUpdatedStub = stub
}

func (fake *Update) SpecUpdatedReturns(result1 bool) {
	fake.specUpdatedMutex.Lock()
	defer fake.specUpdatedMutex.Unlock()
	fake.SpecUpdatedStub = nil
	fake.specUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) SpecUpdatedReturnsOnCall(i int, result1 bool) {
	fake.specUpdatedMutex.Lock()
	defer fake.specUpdatedMutex.Unlock()
	fake.SpecUpdatedStub = nil
	if fake.specUpdatedReturnsOnCall == nil {
		fake.specUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.specUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) TLSCAOverridesUpdated() bool {
	fake.tLSCAOverridesUpdatedMutex.Lock()
	ret, specificReturn := fake.tLSCAOverridesUpdatedReturnsOnCall[len(fake.tLSCAOverridesUpdatedArgsForCall)]
	fake.tLSCAOverridesUpdatedArgsForCall = append(fake.tLSCAOverridesUpdatedArgsForCall, struct {
	}{})
	fake.recordInvocation("TLSCAOverridesUpdated", []interface{}{})
	fake.tLSCAOverridesUpdatedMutex.Unlock()
	if fake.TLSCAOverridesUpdatedStub != nil {
		return fake.TLSCAOverridesUpdatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.tLSCAOverridesUpdatedReturns
	return fakeReturns.result1
}

func (fake *Update) TLSCAOverridesUpdatedCallCount() int {
	fake.tLSCAOverridesUpdatedMutex.RLock()
	defer fake.tLSCAOverridesUpdatedMutex.RUnlock()
	return len(fake.tLSCAOverridesUpdatedArgsForCall)
}

func (fake *Update) TLSCAOverridesUpdatedCalls(stub func() bool) {
	fake.tLSCAOverridesUpdatedMutex.Lock()
	defer fake.tLSCAOverridesUpdatedMutex.Unlock()
	fake.TLSCAOverridesUpdatedStub = stub
}

func (fake *Update) TLSCAOverridesUpdatedReturns(result1 bool) {
	fake.tLSCAOverridesUpdatedMutex.Lock()
	defer fake.tLSCAOverridesUpdatedMutex.Unlock()
	fake.TLSCAOverridesUpdatedStub = nil
	fake.tLSCAOverridesUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) TLSCAOverridesUpdatedReturnsOnCall(i int, result1 bool) {
	fake.tLSCAOverridesUpdatedMutex.Lock()
	defer fake.tLSCAOverridesUpdatedMutex.Unlock()
	fake.TLSCAOverridesUpdatedStub = nil
	if fake.tLSCAOverridesUpdatedReturnsOnCall == nil {
		fake.tLSCAOverridesUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.tLSCAOverridesUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cACryptoCreatedMutex.RLock()
	defer fake.cACryptoCreatedMutex.RUnlock()
	fake.cACryptoUpdatedMutex.RLock()
	defer fake.cACryptoUpdatedMutex.RUnlock()
	fake.cAOverridesUpdatedMutex.RLock()
	defer fake.cAOverridesUpdatedMutex.RUnlock()
	fake.cATagUpdatedMutex.RLock()
	defer fake.cATagUpdatedMutex.RUnlock()
	fake.configOverridesUpdatedMutex.RLock()
	defer fake.configOverridesUpdatedMutex.RUnlock()
	fake.fabricVersionUpdatedMutex.RLock()
	defer fake.fabricVersionUpdatedMutex.RUnlock()
	fake.imagesUpdatedMutex.RLock()
	defer fake.imagesUpdatedMutex.RUnlock()
	fake.renewTLSCertMutex.RLock()
	defer fake.renewTLSCertMutex.RUnlock()
	fake.restartNeededMutex.RLock()
	defer fake.restartNeededMutex.RUnlock()
	fake.specUpdatedMutex.RLock()
	defer fake.specUpdatedMutex.RUnlock()
	fake.tLSCAOverridesUpdatedMutex.RLock()
	defer fake.tLSCAOverridesUpdatedMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Update) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ baseca.Update = new(Update)
