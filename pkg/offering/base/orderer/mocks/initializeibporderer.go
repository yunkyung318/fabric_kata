// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/IBM-Blockchain/fabric-operator/api/v1beta1"
	"github.com/IBM-Blockchain/fabric-operator/pkg/initializer/common"
	"github.com/IBM-Blockchain/fabric-operator/pkg/initializer/common/config"
	initializer "github.com/IBM-Blockchain/fabric-operator/pkg/initializer/orderer"
	baseorderer "github.com/IBM-Blockchain/fabric-operator/pkg/offering/base/orderer"
	v1 "k8s.io/api/core/v1"
)

type InitializeIBPOrderer struct {
	CheckIfAdminCertsUpdatedStub        func(*v1beta1.IBPOrderer) (bool, error)
	checkIfAdminCertsUpdatedMutex       sync.RWMutex
	checkIfAdminCertsUpdatedArgsForCall []struct {
		arg1 *v1beta1.IBPOrderer
	}
	checkIfAdminCertsUpdatedReturns struct {
		result1 bool
		result2 error
	}
	checkIfAdminCertsUpdatedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CreateStub        func(initializer.OrdererConfig, initializer.IBPOrderer, string) (*initializer.Response, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 initializer.OrdererConfig
		arg2 initializer.IBPOrderer
		arg3 string
	}
	createReturns struct {
		result1 *initializer.Response
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 *initializer.Response
		result2 error
	}
	CreateOrUpdateConfigMapStub        func(*v1beta1.IBPOrderer, initializer.OrdererConfig) error
	createOrUpdateConfigMapMutex       sync.RWMutex
	createOrUpdateConfigMapArgsForCall []struct {
		arg1 *v1beta1.IBPOrderer
		arg2 initializer.OrdererConfig
	}
	createOrUpdateConfigMapReturns struct {
		result1 error
	}
	createOrUpdateConfigMapReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStub        func(*v1beta1.IBPOrderer) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 *v1beta1.IBPOrderer
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	GenerateSecretsStub        func(common.SecretType, *v1beta1.IBPOrderer, *config.Response) error
	generateSecretsMutex       sync.RWMutex
	generateSecretsArgsForCall []struct {
		arg1 common.SecretType
		arg2 *v1beta1.IBPOrderer
		arg3 *config.Response
	}
	generateSecretsReturns struct {
		result1 error
	}
	generateSecretsReturnsOnCall map[int]struct {
		result1 error
	}
	GenerateSecretsFromResponseStub        func(*v1beta1.IBPOrderer, *config.CryptoResponse) error
	generateSecretsFromResponseMutex       sync.RWMutex
	generateSecretsFromResponseArgsForCall []struct {
		arg1 *v1beta1.IBPOrderer
		arg2 *config.CryptoResponse
	}
	generateSecretsFromResponseReturns struct {
		result1 error
	}
	generateSecretsFromResponseReturnsOnCall map[int]struct {
		result1 error
	}
	GetConfigFromConfigMapStub        func(*v1beta1.IBPOrderer) (*v1.ConfigMap, error)
	getConfigFromConfigMapMutex       sync.RWMutex
	getConfigFromConfigMapArgsForCall []struct {
		arg1 *v1beta1.IBPOrderer
	}
	getConfigFromConfigMapReturns struct {
		result1 *v1.ConfigMap
		result2 error
	}
	getConfigFromConfigMapReturnsOnCall map[int]struct {
		result1 *v1.ConfigMap
		result2 error
	}
	GetCoreConfigFromBytesStub        func(*v1beta1.IBPOrderer, []byte) (initializer.OrdererConfig, error)
	getCoreConfigFromBytesMutex       sync.RWMutex
	getCoreConfigFromBytesArgsForCall []struct {
		arg1 *v1beta1.IBPOrderer
		arg2 []byte
	}
	getCoreConfigFromBytesReturns struct {
		result1 initializer.OrdererConfig
		result2 error
	}
	getCoreConfigFromBytesReturnsOnCall map[int]struct {
		result1 initializer.OrdererConfig
		result2 error
	}
	GetCoreConfigFromFileStub        func(*v1beta1.IBPOrderer, string) (initializer.OrdererConfig, error)
	getCoreConfigFromFileMutex       sync.RWMutex
	getCoreConfigFromFileArgsForCall []struct {
		arg1 *v1beta1.IBPOrderer
		arg2 string
	}
	getCoreConfigFromFileReturns struct {
		result1 initializer.OrdererConfig
		result2 error
	}
	getCoreConfigFromFileReturnsOnCall map[int]struct {
		result1 initializer.OrdererConfig
		result2 error
	}
	GetCryptoStub        func(*v1beta1.IBPOrderer) (*config.CryptoResponse, error)
	getCryptoMutex       sync.RWMutex
	getCryptoArgsForCall []struct {
		arg1 *v1beta1.IBPOrderer
	}
	getCryptoReturns struct {
		result1 *config.CryptoResponse
		result2 error
	}
	getCryptoReturnsOnCall map[int]struct {
		result1 *config.CryptoResponse
		result2 error
	}
	GetInitOrdererStub        func(*v1beta1.IBPOrderer, string) (*initializer.Orderer, error)
	getInitOrdererMutex       sync.RWMutex
	getInitOrdererArgsForCall []struct {
		arg1 *v1beta1.IBPOrderer
		arg2 string
	}
	getInitOrdererReturns struct {
		result1 *initializer.Orderer
		result2 error
	}
	getInitOrdererReturnsOnCall map[int]struct {
		result1 *initializer.Orderer
		result2 error
	}
	GetUpdatedOrdererStub        func(*v1beta1.IBPOrderer) (*initializer.Orderer, error)
	getUpdatedOrdererMutex       sync.RWMutex
	getUpdatedOrdererArgsForCall []struct {
		arg1 *v1beta1.IBPOrderer
	}
	getUpdatedOrdererReturns struct {
		result1 *initializer.Orderer
		result2 error
	}
	getUpdatedOrdererReturnsOnCall map[int]struct {
		result1 *initializer.Orderer
		result2 error
	}
	MissingCryptoStub        func(*v1beta1.IBPOrderer) bool
	missingCryptoMutex       sync.RWMutex
	missingCryptoArgsForCall []struct {
		arg1 *v1beta1.IBPOrderer
	}
	missingCryptoReturns struct {
		result1 bool
	}
	missingCryptoReturnsOnCall map[int]struct {
		result1 bool
	}
	UpdateStub        func(initializer.OrdererConfig, initializer.IBPOrderer) (*initializer.Response, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 initializer.OrdererConfig
		arg2 initializer.IBPOrderer
	}
	updateReturns struct {
		result1 *initializer.Response
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 *initializer.Response
		result2 error
	}
	UpdateAdminSecretStub        func(*v1beta1.IBPOrderer) error
	updateAdminSecretMutex       sync.RWMutex
	updateAdminSecretArgsForCall []struct {
		arg1 *v1beta1.IBPOrderer
	}
	updateAdminSecretReturns struct {
		result1 error
	}
	updateAdminSecretReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateSecretsStub        func(common.SecretType, *v1beta1.IBPOrderer, *config.Response) error
	updateSecretsMutex       sync.RWMutex
	updateSecretsArgsForCall []struct {
		arg1 common.SecretType
		arg2 *v1beta1.IBPOrderer
		arg3 *config.Response
	}
	updateSecretsReturns struct {
		result1 error
	}
	updateSecretsReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateSecretsFromResponseStub        func(*v1beta1.IBPOrderer, *config.CryptoResponse) error
	updateSecretsFromResponseMutex       sync.RWMutex
	updateSecretsFromResponseArgsForCall []struct {
		arg1 *v1beta1.IBPOrderer
		arg2 *config.CryptoResponse
	}
	updateSecretsFromResponseReturns struct {
		result1 error
	}
	updateSecretsFromResponseReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *InitializeIBPOrderer) CheckIfAdminCertsUpdated(arg1 *v1beta1.IBPOrderer) (bool, error) {
	fake.checkIfAdminCertsUpdatedMutex.Lock()
	ret, specificReturn := fake.checkIfAdminCertsUpdatedReturnsOnCall[len(fake.checkIfAdminCertsUpdatedArgsForCall)]
	fake.checkIfAdminCertsUpdatedArgsForCall = append(fake.checkIfAdminCertsUpdatedArgsForCall, struct {
		arg1 *v1beta1.IBPOrderer
	}{arg1})
	fake.recordInvocation("CheckIfAdminCertsUpdated", []interface{}{arg1})
	fake.checkIfAdminCertsUpdatedMutex.Unlock()
	if fake.CheckIfAdminCertsUpdatedStub != nil {
		return fake.CheckIfAdminCertsUpdatedStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.checkIfAdminCertsUpdatedReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *InitializeIBPOrderer) CheckIfAdminCertsUpdatedCallCount() int {
	fake.checkIfAdminCertsUpdatedMutex.RLock()
	defer fake.checkIfAdminCertsUpdatedMutex.RUnlock()
	return len(fake.checkIfAdminCertsUpdatedArgsForCall)
}

func (fake *InitializeIBPOrderer) CheckIfAdminCertsUpdatedCalls(stub func(*v1beta1.IBPOrderer) (bool, error)) {
	fake.checkIfAdminCertsUpdatedMutex.Lock()
	defer fake.checkIfAdminCertsUpdatedMutex.Unlock()
	fake.CheckIfAdminCertsUpdatedStub = stub
}

func (fake *InitializeIBPOrderer) CheckIfAdminCertsUpdatedArgsForCall(i int) *v1beta1.IBPOrderer {
	fake.checkIfAdminCertsUpdatedMutex.RLock()
	defer fake.checkIfAdminCertsUpdatedMutex.RUnlock()
	argsForCall := fake.checkIfAdminCertsUpdatedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *InitializeIBPOrderer) CheckIfAdminCertsUpdatedReturns(result1 bool, result2 error) {
	fake.checkIfAdminCertsUpdatedMutex.Lock()
	defer fake.checkIfAdminCertsUpdatedMutex.Unlock()
	fake.CheckIfAdminCertsUpdatedStub = nil
	fake.checkIfAdminCertsUpdatedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *InitializeIBPOrderer) CheckIfAdminCertsUpdatedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.checkIfAdminCertsUpdatedMutex.Lock()
	defer fake.checkIfAdminCertsUpdatedMutex.Unlock()
	fake.CheckIfAdminCertsUpdatedStub = nil
	if fake.checkIfAdminCertsUpdatedReturnsOnCall == nil {
		fake.checkIfAdminCertsUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkIfAdminCertsUpdatedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *InitializeIBPOrderer) Create(arg1 initializer.OrdererConfig, arg2 initializer.IBPOrderer, arg3 string) (*initializer.Response, error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 initializer.OrdererConfig
		arg2 initializer.IBPOrderer
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("Create", []interface{}{arg1, arg2, arg3})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *InitializeIBPOrderer) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *InitializeIBPOrderer) CreateCalls(stub func(initializer.OrdererConfig, initializer.IBPOrderer, string) (*initializer.Response, error)) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *InitializeIBPOrderer) CreateArgsForCall(i int) (initializer.OrdererConfig, initializer.IBPOrderer, string) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *InitializeIBPOrderer) CreateReturns(result1 *initializer.Response, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 *initializer.Response
		result2 error
	}{result1, result2}
}

func (fake *InitializeIBPOrderer) CreateReturnsOnCall(i int, result1 *initializer.Response, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 *initializer.Response
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 *initializer.Response
		result2 error
	}{result1, result2}
}

func (fake *InitializeIBPOrderer) CreateOrUpdateConfigMap(arg1 *v1beta1.IBPOrderer, arg2 initializer.OrdererConfig) error {
	fake.createOrUpdateConfigMapMutex.Lock()
	ret, specificReturn := fake.createOrUpdateConfigMapReturnsOnCall[len(fake.createOrUpdateConfigMapArgsForCall)]
	fake.createOrUpdateConfigMapArgsForCall = append(fake.createOrUpdateConfigMapArgsForCall, struct {
		arg1 *v1beta1.IBPOrderer
		arg2 initializer.OrdererConfig
	}{arg1, arg2})
	fake.recordInvocation("CreateOrUpdateConfigMap", []interface{}{arg1, arg2})
	fake.createOrUpdateConfigMapMutex.Unlock()
	if fake.CreateOrUpdateConfigMapStub != nil {
		return fake.CreateOrUpdateConfigMapStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createOrUpdateConfigMapReturns
	return fakeReturns.result1
}

func (fake *InitializeIBPOrderer) CreateOrUpdateConfigMapCallCount() int {
	fake.createOrUpdateConfigMapMutex.RLock()
	defer fake.createOrUpdateConfigMapMutex.RUnlock()
	return len(fake.createOrUpdateConfigMapArgsForCall)
}

func (fake *InitializeIBPOrderer) CreateOrUpdateConfigMapCalls(stub func(*v1beta1.IBPOrderer, initializer.OrdererConfig) error) {
	fake.createOrUpdateConfigMapMutex.Lock()
	defer fake.createOrUpdateConfigMapMutex.Unlock()
	fake.CreateOrUpdateConfigMapStub = stub
}

func (fake *InitializeIBPOrderer) CreateOrUpdateConfigMapArgsForCall(i int) (*v1beta1.IBPOrderer, initializer.OrdererConfig) {
	fake.createOrUpdateConfigMapMutex.RLock()
	defer fake.createOrUpdateConfigMapMutex.RUnlock()
	argsForCall := fake.createOrUpdateConfigMapArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *InitializeIBPOrderer) CreateOrUpdateConfigMapReturns(result1 error) {
	fake.createOrUpdateConfigMapMutex.Lock()
	defer fake.createOrUpdateConfigMapMutex.Unlock()
	fake.CreateOrUpdateConfigMapStub = nil
	fake.createOrUpdateConfigMapReturns = struct {
		result1 error
	}{result1}
}

func (fake *InitializeIBPOrderer) CreateOrUpdateConfigMapReturnsOnCall(i int, result1 error) {
	fake.createOrUpdateConfigMapMutex.Lock()
	defer fake.createOrUpdateConfigMapMutex.Unlock()
	fake.CreateOrUpdateConfigMapStub = nil
	if fake.createOrUpdateConfigMapReturnsOnCall == nil {
		fake.createOrUpdateConfigMapReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createOrUpdateConfigMapReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *InitializeIBPOrderer) Delete(arg1 *v1beta1.IBPOrderer) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 *v1beta1.IBPOrderer
	}{arg1})
	fake.recordInvocation("Delete", []interface{}{arg1})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteReturns
	return fakeReturns.result1
}

func (fake *InitializeIBPOrderer) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *InitializeIBPOrderer) DeleteCalls(stub func(*v1beta1.IBPOrderer) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *InitializeIBPOrderer) DeleteArgsForCall(i int) *v1beta1.IBPOrderer {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *InitializeIBPOrderer) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *InitializeIBPOrderer) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *InitializeIBPOrderer) GenerateSecrets(arg1 common.SecretType, arg2 *v1beta1.IBPOrderer, arg3 *config.Response) error {
	fake.generateSecretsMutex.Lock()
	ret, specificReturn := fake.generateSecretsReturnsOnCall[len(fake.generateSecretsArgsForCall)]
	fake.generateSecretsArgsForCall = append(fake.generateSecretsArgsForCall, struct {
		arg1 common.SecretType
		arg2 *v1beta1.IBPOrderer
		arg3 *config.Response
	}{arg1, arg2, arg3})
	fake.recordInvocation("GenerateSecrets", []interface{}{arg1, arg2, arg3})
	fake.generateSecretsMutex.Unlock()
	if fake.GenerateSecretsStub != nil {
		return fake.GenerateSecretsStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.generateSecretsReturns
	return fakeReturns.result1
}

func (fake *InitializeIBPOrderer) GenerateSecretsCallCount() int {
	fake.generateSecretsMutex.RLock()
	defer fake.generateSecretsMutex.RUnlock()
	return len(fake.generateSecretsArgsForCall)
}

func (fake *InitializeIBPOrderer) GenerateSecretsCalls(stub func(common.SecretType, *v1beta1.IBPOrderer, *config.Response) error) {
	fake.generateSecretsMutex.Lock()
	defer fake.generateSecretsMutex.Unlock()
	fake.GenerateSecretsStub = stub
}

func (fake *InitializeIBPOrderer) GenerateSecretsArgsForCall(i int) (common.SecretType, *v1beta1.IBPOrderer, *config.Response) {
	fake.generateSecretsMutex.RLock()
	defer fake.generateSecretsMutex.RUnlock()
	argsForCall := fake.generateSecretsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *InitializeIBPOrderer) GenerateSecretsReturns(result1 error) {
	fake.generateSecretsMutex.Lock()
	defer fake.generateSecretsMutex.Unlock()
	fake.GenerateSecretsStub = nil
	fake.generateSecretsReturns = struct {
		result1 error
	}{result1}
}

func (fake *InitializeIBPOrderer) GenerateSecretsReturnsOnCall(i int, result1 error) {
	fake.generateSecretsMutex.Lock()
	defer fake.generateSecretsMutex.Unlock()
	fake.GenerateSecretsStub = nil
	if fake.generateSecretsReturnsOnCall == nil {
		fake.generateSecretsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.generateSecretsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *InitializeIBPOrderer) GenerateSecretsFromResponse(arg1 *v1beta1.IBPOrderer, arg2 *config.CryptoResponse) error {
	fake.generateSecretsFromResponseMutex.Lock()
	ret, specificReturn := fake.generateSecretsFromResponseReturnsOnCall[len(fake.generateSecretsFromResponseArgsForCall)]
	fake.generateSecretsFromResponseArgsForCall = append(fake.generateSecretsFromResponseArgsForCall, struct {
		arg1 *v1beta1.IBPOrderer
		arg2 *config.CryptoResponse
	}{arg1, arg2})
	fake.recordInvocation("GenerateSecretsFromResponse", []interface{}{arg1, arg2})
	fake.generateSecretsFromResponseMutex.Unlock()
	if fake.GenerateSecretsFromResponseStub != nil {
		return fake.GenerateSecretsFromResponseStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.generateSecretsFromResponseReturns
	return fakeReturns.result1
}

func (fake *InitializeIBPOrderer) GenerateSecretsFromResponseCallCount() int {
	fake.generateSecretsFromResponseMutex.RLock()
	defer fake.generateSecretsFromResponseMutex.RUnlock()
	return len(fake.generateSecretsFromResponseArgsForCall)
}

func (fake *InitializeIBPOrderer) GenerateSecretsFromResponseCalls(stub func(*v1beta1.IBPOrderer, *config.CryptoResponse) error) {
	fake.generateSecretsFromResponseMutex.Lock()
	defer fake.generateSecretsFromResponseMutex.Unlock()
	fake.GenerateSecretsFromResponseStub = stub
}

func (fake *InitializeIBPOrderer) GenerateSecretsFromResponseArgsForCall(i int) (*v1beta1.IBPOrderer, *config.CryptoResponse) {
	fake.generateSecretsFromResponseMutex.RLock()
	defer fake.generateSecretsFromResponseMutex.RUnlock()
	argsForCall := fake.generateSecretsFromResponseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *InitializeIBPOrderer) GenerateSecretsFromResponseReturns(result1 error) {
	fake.generateSecretsFromResponseMutex.Lock()
	defer fake.generateSecretsFromResponseMutex.Unlock()
	fake.GenerateSecretsFromResponseStub = nil
	fake.generateSecretsFromResponseReturns = struct {
		result1 error
	}{result1}
}

func (fake *InitializeIBPOrderer) GenerateSecretsFromResponseReturnsOnCall(i int, result1 error) {
	fake.generateSecretsFromResponseMutex.Lock()
	defer fake.generateSecretsFromResponseMutex.Unlock()
	fake.GenerateSecretsFromResponseStub = nil
	if fake.generateSecretsFromResponseReturnsOnCall == nil {
		fake.generateSecretsFromResponseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.generateSecretsFromResponseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *InitializeIBPOrderer) GetConfigFromConfigMap(arg1 *v1beta1.IBPOrderer) (*v1.ConfigMap, error) {
	fake.getConfigFromConfigMapMutex.Lock()
	ret, specificReturn := fake.getConfigFromConfigMapReturnsOnCall[len(fake.getConfigFromConfigMapArgsForCall)]
	fake.getConfigFromConfigMapArgsForCall = append(fake.getConfigFromConfigMapArgsForCall, struct {
		arg1 *v1beta1.IBPOrderer
	}{arg1})
	fake.recordInvocation("GetConfigFromConfigMap", []interface{}{arg1})
	fake.getConfigFromConfigMapMutex.Unlock()
	if fake.GetConfigFromConfigMapStub != nil {
		return fake.GetConfigFromConfigMapStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getConfigFromConfigMapReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *InitializeIBPOrderer) GetConfigFromConfigMapCallCount() int {
	fake.getConfigFromConfigMapMutex.RLock()
	defer fake.getConfigFromConfigMapMutex.RUnlock()
	return len(fake.getConfigFromConfigMapArgsForCall)
}

func (fake *InitializeIBPOrderer) GetConfigFromConfigMapCalls(stub func(*v1beta1.IBPOrderer) (*v1.ConfigMap, error)) {
	fake.getConfigFromConfigMapMutex.Lock()
	defer fake.getConfigFromConfigMapMutex.Unlock()
	fake.GetConfigFromConfigMapStub = stub
}

func (fake *InitializeIBPOrderer) GetConfigFromConfigMapArgsForCall(i int) *v1beta1.IBPOrderer {
	fake.getConfigFromConfigMapMutex.RLock()
	defer fake.getConfigFromConfigMapMutex.RUnlock()
	argsForCall := fake.getConfigFromConfigMapArgsForCall[i]
	return argsForCall.arg1
}

func (fake *InitializeIBPOrderer) GetConfigFromConfigMapReturns(result1 *v1.ConfigMap, result2 error) {
	fake.getConfigFromConfigMapMutex.Lock()
	defer fake.getConfigFromConfigMapMutex.Unlock()
	fake.GetConfigFromConfigMapStub = nil
	fake.getConfigFromConfigMapReturns = struct {
		result1 *v1.ConfigMap
		result2 error
	}{result1, result2}
}

func (fake *InitializeIBPOrderer) GetConfigFromConfigMapReturnsOnCall(i int, result1 *v1.ConfigMap, result2 error) {
	fake.getConfigFromConfigMapMutex.Lock()
	defer fake.getConfigFromConfigMapMutex.Unlock()
	fake.GetConfigFromConfigMapStub = nil
	if fake.getConfigFromConfigMapReturnsOnCall == nil {
		fake.getConfigFromConfigMapReturnsOnCall = make(map[int]struct {
			result1 *v1.ConfigMap
			result2 error
		})
	}
	fake.getConfigFromConfigMapReturnsOnCall[i] = struct {
		result1 *v1.ConfigMap
		result2 error
	}{result1, result2}
}

func (fake *InitializeIBPOrderer) GetCoreConfigFromBytes(arg1 *v1beta1.IBPOrderer, arg2 []byte) (initializer.OrdererConfig, error) {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.getCoreConfigFromBytesMutex.Lock()
	ret, specificReturn := fake.getCoreConfigFromBytesReturnsOnCall[len(fake.getCoreConfigFromBytesArgsForCall)]
	fake.getCoreConfigFromBytesArgsForCall = append(fake.getCoreConfigFromBytesArgsForCall, struct {
		arg1 *v1beta1.IBPOrderer
		arg2 []byte
	}{arg1, arg2Copy})
	fake.recordInvocation("GetCoreConfigFromBytes", []interface{}{arg1, arg2Copy})
	fake.getCoreConfigFromBytesMutex.Unlock()
	if fake.GetCoreConfigFromBytesStub != nil {
		return fake.GetCoreConfigFromBytesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getCoreConfigFromBytesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *InitializeIBPOrderer) GetCoreConfigFromBytesCallCount() int {
	fake.getCoreConfigFromBytesMutex.RLock()
	defer fake.getCoreConfigFromBytesMutex.RUnlock()
	return len(fake.getCoreConfigFromBytesArgsForCall)
}

func (fake *InitializeIBPOrderer) GetCoreConfigFromBytesCalls(stub func(*v1beta1.IBPOrderer, []byte) (initializer.OrdererConfig, error)) {
	fake.getCoreConfigFromBytesMutex.Lock()
	defer fake.getCoreConfigFromBytesMutex.Unlock()
	fake.GetCoreConfigFromBytesStub = stub
}

func (fake *InitializeIBPOrderer) GetCoreConfigFromBytesArgsForCall(i int) (*v1beta1.IBPOrderer, []byte) {
	fake.getCoreConfigFromBytesMutex.RLock()
	defer fake.getCoreConfigFromBytesMutex.RUnlock()
	argsForCall := fake.getCoreConfigFromBytesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *InitializeIBPOrderer) GetCoreConfigFromBytesReturns(result1 initializer.OrdererConfig, result2 error) {
	fake.getCoreConfigFromBytesMutex.Lock()
	defer fake.getCoreConfigFromBytesMutex.Unlock()
	fake.GetCoreConfigFromBytesStub = nil
	fake.getCoreConfigFromBytesReturns = struct {
		result1 initializer.OrdererConfig
		result2 error
	}{result1, result2}
}

func (fake *InitializeIBPOrderer) GetCoreConfigFromBytesReturnsOnCall(i int, result1 initializer.OrdererConfig, result2 error) {
	fake.getCoreConfigFromBytesMutex.Lock()
	defer fake.getCoreConfigFromBytesMutex.Unlock()
	fake.GetCoreConfigFromBytesStub = nil
	if fake.getCoreConfigFromBytesReturnsOnCall == nil {
		fake.getCoreConfigFromBytesReturnsOnCall = make(map[int]struct {
			result1 initializer.OrdererConfig
			result2 error
		})
	}
	fake.getCoreConfigFromBytesReturnsOnCall[i] = struct {
		result1 initializer.OrdererConfig
		result2 error
	}{result1, result2}
}

func (fake *InitializeIBPOrderer) GetCoreConfigFromFile(arg1 *v1beta1.IBPOrderer, arg2 string) (initializer.OrdererConfig, error) {
	fake.getCoreConfigFromFileMutex.Lock()
	ret, specificReturn := fake.getCoreConfigFromFileReturnsOnCall[len(fake.getCoreConfigFromFileArgsForCall)]
	fake.getCoreConfigFromFileArgsForCall = append(fake.getCoreConfigFromFileArgsForCall, struct {
		arg1 *v1beta1.IBPOrderer
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetCoreConfigFromFile", []interface{}{arg1, arg2})
	fake.getCoreConfigFromFileMutex.Unlock()
	if fake.GetCoreConfigFromFileStub != nil {
		return fake.GetCoreConfigFromFileStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getCoreConfigFromFileReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *InitializeIBPOrderer) GetCoreConfigFromFileCallCount() int {
	fake.getCoreConfigFromFileMutex.RLock()
	defer fake.getCoreConfigFromFileMutex.RUnlock()
	return len(fake.getCoreConfigFromFileArgsForCall)
}

func (fake *InitializeIBPOrderer) GetCoreConfigFromFileCalls(stub func(*v1beta1.IBPOrderer, string) (initializer.OrdererConfig, error)) {
	fake.getCoreConfigFromFileMutex.Lock()
	defer fake.getCoreConfigFromFileMutex.Unlock()
	fake.GetCoreConfigFromFileStub = stub
}

func (fake *InitializeIBPOrderer) GetCoreConfigFromFileArgsForCall(i int) (*v1beta1.IBPOrderer, string) {
	fake.getCoreConfigFromFileMutex.RLock()
	defer fake.getCoreConfigFromFileMutex.RUnlock()
	argsForCall := fake.getCoreConfigFromFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *InitializeIBPOrderer) GetCoreConfigFromFileReturns(result1 initializer.OrdererConfig, result2 error) {
	fake.getCoreConfigFromFileMutex.Lock()
	defer fake.getCoreConfigFromFileMutex.Unlock()
	fake.GetCoreConfigFromFileStub = nil
	fake.getCoreConfigFromFileReturns = struct {
		result1 initializer.OrdererConfig
		result2 error
	}{result1, result2}
}

func (fake *InitializeIBPOrderer) GetCoreConfigFromFileReturnsOnCall(i int, result1 initializer.OrdererConfig, result2 error) {
	fake.getCoreConfigFromFileMutex.Lock()
	defer fake.getCoreConfigFromFileMutex.Unlock()
	fake.GetCoreConfigFromFileStub = nil
	if fake.getCoreConfigFromFileReturnsOnCall == nil {
		fake.getCoreConfigFromFileReturnsOnCall = make(map[int]struct {
			result1 initializer.OrdererConfig
			result2 error
		})
	}
	fake.getCoreConfigFromFileReturnsOnCall[i] = struct {
		result1 initializer.OrdererConfig
		result2 error
	}{result1, result2}
}

func (fake *InitializeIBPOrderer) GetCrypto(arg1 *v1beta1.IBPOrderer) (*config.CryptoResponse, error) {
	fake.getCryptoMutex.Lock()
	ret, specificReturn := fake.getCryptoReturnsOnCall[len(fake.getCryptoArgsForCall)]
	fake.getCryptoArgsForCall = append(fake.getCryptoArgsForCall, struct {
		arg1 *v1beta1.IBPOrderer
	}{arg1})
	fake.recordInvocation("GetCrypto", []interface{}{arg1})
	fake.getCryptoMutex.Unlock()
	if fake.GetCryptoStub != nil {
		return fake.GetCryptoStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getCryptoReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *InitializeIBPOrderer) GetCryptoCallCount() int {
	fake.getCryptoMutex.RLock()
	defer fake.getCryptoMutex.RUnlock()
	return len(fake.getCryptoArgsForCall)
}

func (fake *InitializeIBPOrderer) GetCryptoCalls(stub func(*v1beta1.IBPOrderer) (*config.CryptoResponse, error)) {
	fake.getCryptoMutex.Lock()
	defer fake.getCryptoMutex.Unlock()
	fake.GetCryptoStub = stub
}

func (fake *InitializeIBPOrderer) GetCryptoArgsForCall(i int) *v1beta1.IBPOrderer {
	fake.getCryptoMutex.RLock()
	defer fake.getCryptoMutex.RUnlock()
	argsForCall := fake.getCryptoArgsForCall[i]
	return argsForCall.arg1
}

func (fake *InitializeIBPOrderer) GetCryptoReturns(result1 *config.CryptoResponse, result2 error) {
	fake.getCryptoMutex.Lock()
	defer fake.getCryptoMutex.Unlock()
	fake.GetCryptoStub = nil
	fake.getCryptoReturns = struct {
		result1 *config.CryptoResponse
		result2 error
	}{result1, result2}
}

func (fake *InitializeIBPOrderer) GetCryptoReturnsOnCall(i int, result1 *config.CryptoResponse, result2 error) {
	fake.getCryptoMutex.Lock()
	defer fake.getCryptoMutex.Unlock()
	fake.GetCryptoStub = nil
	if fake.getCryptoReturnsOnCall == nil {
		fake.getCryptoReturnsOnCall = make(map[int]struct {
			result1 *config.CryptoResponse
			result2 error
		})
	}
	fake.getCryptoReturnsOnCall[i] = struct {
		result1 *config.CryptoResponse
		result2 error
	}{result1, result2}
}

func (fake *InitializeIBPOrderer) GetInitOrderer(arg1 *v1beta1.IBPOrderer, arg2 string) (*initializer.Orderer, error) {
	fake.getInitOrdererMutex.Lock()
	ret, specificReturn := fake.getInitOrdererReturnsOnCall[len(fake.getInitOrdererArgsForCall)]
	fake.getInitOrdererArgsForCall = append(fake.getInitOrdererArgsForCall, struct {
		arg1 *v1beta1.IBPOrderer
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetInitOrderer", []interface{}{arg1, arg2})
	fake.getInitOrdererMutex.Unlock()
	if fake.GetInitOrdererStub != nil {
		return fake.GetInitOrdererStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getInitOrdererReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *InitializeIBPOrderer) GetInitOrdererCallCount() int {
	fake.getInitOrdererMutex.RLock()
	defer fake.getInitOrdererMutex.RUnlock()
	return len(fake.getInitOrdererArgsForCall)
}

func (fake *InitializeIBPOrderer) GetInitOrdererCalls(stub func(*v1beta1.IBPOrderer, string) (*initializer.Orderer, error)) {
	fake.getInitOrdererMutex.Lock()
	defer fake.getInitOrdererMutex.Unlock()
	fake.GetInitOrdererStub = stub
}

func (fake *InitializeIBPOrderer) GetInitOrdererArgsForCall(i int) (*v1beta1.IBPOrderer, string) {
	fake.getInitOrdererMutex.RLock()
	defer fake.getInitOrdererMutex.RUnlock()
	argsForCall := fake.getInitOrdererArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *InitializeIBPOrderer) GetInitOrdererReturns(result1 *initializer.Orderer, result2 error) {
	fake.getInitOrdererMutex.Lock()
	defer fake.getInitOrdererMutex.Unlock()
	fake.GetInitOrdererStub = nil
	fake.getInitOrdererReturns = struct {
		result1 *initializer.Orderer
		result2 error
	}{result1, result2}
}

func (fake *InitializeIBPOrderer) GetInitOrdererReturnsOnCall(i int, result1 *initializer.Orderer, result2 error) {
	fake.getInitOrdererMutex.Lock()
	defer fake.getInitOrdererMutex.Unlock()
	fake.GetInitOrdererStub = nil
	if fake.getInitOrdererReturnsOnCall == nil {
		fake.getInitOrdererReturnsOnCall = make(map[int]struct {
			result1 *initializer.Orderer
			result2 error
		})
	}
	fake.getInitOrdererReturnsOnCall[i] = struct {
		result1 *initializer.Orderer
		result2 error
	}{result1, result2}
}

func (fake *InitializeIBPOrderer) GetUpdatedOrderer(arg1 *v1beta1.IBPOrderer) (*initializer.Orderer, error) {
	fake.getUpdatedOrdererMutex.Lock()
	ret, specificReturn := fake.getUpdatedOrdererReturnsOnCall[len(fake.getUpdatedOrdererArgsForCall)]
	fake.getUpdatedOrdererArgsForCall = append(fake.getUpdatedOrdererArgsForCall, struct {
		arg1 *v1beta1.IBPOrderer
	}{arg1})
	fake.recordInvocation("GetUpdatedOrderer", []interface{}{arg1})
	fake.getUpdatedOrdererMutex.Unlock()
	if fake.GetUpdatedOrdererStub != nil {
		return fake.GetUpdatedOrdererStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getUpdatedOrdererReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *InitializeIBPOrderer) GetUpdatedOrdererCallCount() int {
	fake.getUpdatedOrdererMutex.RLock()
	defer fake.getUpdatedOrdererMutex.RUnlock()
	return len(fake.getUpdatedOrdererArgsForCall)
}

func (fake *InitializeIBPOrderer) GetUpdatedOrdererCalls(stub func(*v1beta1.IBPOrderer) (*initializer.Orderer, error)) {
	fake.getUpdatedOrdererMutex.Lock()
	defer fake.getUpdatedOrdererMutex.Unlock()
	fake.GetUpdatedOrdererStub = stub
}

func (fake *InitializeIBPOrderer) GetUpdatedOrdererArgsForCall(i int) *v1beta1.IBPOrderer {
	fake.getUpdatedOrdererMutex.RLock()
	defer fake.getUpdatedOrdererMutex.RUnlock()
	argsForCall := fake.getUpdatedOrdererArgsForCall[i]
	return argsForCall.arg1
}

func (fake *InitializeIBPOrderer) GetUpdatedOrdererReturns(result1 *initializer.Orderer, result2 error) {
	fake.getUpdatedOrdererMutex.Lock()
	defer fake.getUpdatedOrdererMutex.Unlock()
	fake.GetUpdatedOrdererStub = nil
	fake.getUpdatedOrdererReturns = struct {
		result1 *initializer.Orderer
		result2 error
	}{result1, result2}
}

func (fake *InitializeIBPOrderer) GetUpdatedOrdererReturnsOnCall(i int, result1 *initializer.Orderer, result2 error) {
	fake.getUpdatedOrdererMutex.Lock()
	defer fake.getUpdatedOrdererMutex.Unlock()
	fake.GetUpdatedOrdererStub = nil
	if fake.getUpdatedOrdererReturnsOnCall == nil {
		fake.getUpdatedOrdererReturnsOnCall = make(map[int]struct {
			result1 *initializer.Orderer
			result2 error
		})
	}
	fake.getUpdatedOrdererReturnsOnCall[i] = struct {
		result1 *initializer.Orderer
		result2 error
	}{result1, result2}
}

func (fake *InitializeIBPOrderer) MissingCrypto(arg1 *v1beta1.IBPOrderer) bool {
	fake.missingCryptoMutex.Lock()
	ret, specificReturn := fake.missingCryptoReturnsOnCall[len(fake.missingCryptoArgsForCall)]
	fake.missingCryptoArgsForCall = append(fake.missingCryptoArgsForCall, struct {
		arg1 *v1beta1.IBPOrderer
	}{arg1})
	fake.recordInvocation("MissingCrypto", []interface{}{arg1})
	fake.missingCryptoMutex.Unlock()
	if fake.MissingCryptoStub != nil {
		return fake.MissingCryptoStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.missingCryptoReturns
	return fakeReturns.result1
}

func (fake *InitializeIBPOrderer) MissingCryptoCallCount() int {
	fake.missingCryptoMutex.RLock()
	defer fake.missingCryptoMutex.RUnlock()
	return len(fake.missingCryptoArgsForCall)
}

func (fake *InitializeIBPOrderer) MissingCryptoCalls(stub func(*v1beta1.IBPOrderer) bool) {
	fake.missingCryptoMutex.Lock()
	defer fake.missingCryptoMutex.Unlock()
	fake.MissingCryptoStub = stub
}

func (fake *InitializeIBPOrderer) MissingCryptoArgsForCall(i int) *v1beta1.IBPOrderer {
	fake.missingCryptoMutex.RLock()
	defer fake.missingCryptoMutex.RUnlock()
	argsForCall := fake.missingCryptoArgsForCall[i]
	return argsForCall.arg1
}

func (fake *InitializeIBPOrderer) MissingCryptoReturns(result1 bool) {
	fake.missingCryptoMutex.Lock()
	defer fake.missingCryptoMutex.Unlock()
	fake.MissingCryptoStub = nil
	fake.missingCryptoReturns = struct {
		result1 bool
	}{result1}
}

func (fake *InitializeIBPOrderer) MissingCryptoReturnsOnCall(i int, result1 bool) {
	fake.missingCryptoMutex.Lock()
	defer fake.missingCryptoMutex.Unlock()
	fake.MissingCryptoStub = nil
	if fake.missingCryptoReturnsOnCall == nil {
		fake.missingCryptoReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.missingCryptoReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *InitializeIBPOrderer) Update(arg1 initializer.OrdererConfig, arg2 initializer.IBPOrderer) (*initializer.Response, error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 initializer.OrdererConfig
		arg2 initializer.IBPOrderer
	}{arg1, arg2})
	fake.recordInvocation("Update", []interface{}{arg1, arg2})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *InitializeIBPOrderer) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *InitializeIBPOrderer) UpdateCalls(stub func(initializer.OrdererConfig, initializer.IBPOrderer) (*initializer.Response, error)) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *InitializeIBPOrderer) UpdateArgsForCall(i int) (initializer.OrdererConfig, initializer.IBPOrderer) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *InitializeIBPOrderer) UpdateReturns(result1 *initializer.Response, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 *initializer.Response
		result2 error
	}{result1, result2}
}

func (fake *InitializeIBPOrderer) UpdateReturnsOnCall(i int, result1 *initializer.Response, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 *initializer.Response
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 *initializer.Response
		result2 error
	}{result1, result2}
}

func (fake *InitializeIBPOrderer) UpdateAdminSecret(arg1 *v1beta1.IBPOrderer) error {
	fake.updateAdminSecretMutex.Lock()
	ret, specificReturn := fake.updateAdminSecretReturnsOnCall[len(fake.updateAdminSecretArgsForCall)]
	fake.updateAdminSecretArgsForCall = append(fake.updateAdminSecretArgsForCall, struct {
		arg1 *v1beta1.IBPOrderer
	}{arg1})
	fake.recordInvocation("UpdateAdminSecret", []interface{}{arg1})
	fake.updateAdminSecretMutex.Unlock()
	if fake.UpdateAdminSecretStub != nil {
		return fake.UpdateAdminSecretStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateAdminSecretReturns
	return fakeReturns.result1
}

func (fake *InitializeIBPOrderer) UpdateAdminSecretCallCount() int {
	fake.updateAdminSecretMutex.RLock()
	defer fake.updateAdminSecretMutex.RUnlock()
	return len(fake.updateAdminSecretArgsForCall)
}

func (fake *InitializeIBPOrderer) UpdateAdminSecretCalls(stub func(*v1beta1.IBPOrderer) error) {
	fake.updateAdminSecretMutex.Lock()
	defer fake.updateAdminSecretMutex.Unlock()
	fake.UpdateAdminSecretStub = stub
}

func (fake *InitializeIBPOrderer) UpdateAdminSecretArgsForCall(i int) *v1beta1.IBPOrderer {
	fake.updateAdminSecretMutex.RLock()
	defer fake.updateAdminSecretMutex.RUnlock()
	argsForCall := fake.updateAdminSecretArgsForCall[i]
	return argsForCall.arg1
}

func (fake *InitializeIBPOrderer) UpdateAdminSecretReturns(result1 error) {
	fake.updateAdminSecretMutex.Lock()
	defer fake.updateAdminSecretMutex.Unlock()
	fake.UpdateAdminSecretStub = nil
	fake.updateAdminSecretReturns = struct {
		result1 error
	}{result1}
}

func (fake *InitializeIBPOrderer) UpdateAdminSecretReturnsOnCall(i int, result1 error) {
	fake.updateAdminSecretMutex.Lock()
	defer fake.updateAdminSecretMutex.Unlock()
	fake.UpdateAdminSecretStub = nil
	if fake.updateAdminSecretReturnsOnCall == nil {
		fake.updateAdminSecretReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateAdminSecretReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *InitializeIBPOrderer) UpdateSecrets(arg1 common.SecretType, arg2 *v1beta1.IBPOrderer, arg3 *config.Response) error {
	fake.updateSecretsMutex.Lock()
	ret, specificReturn := fake.updateSecretsReturnsOnCall[len(fake.updateSecretsArgsForCall)]
	fake.updateSecretsArgsForCall = append(fake.updateSecretsArgsForCall, struct {
		arg1 common.SecretType
		arg2 *v1beta1.IBPOrderer
		arg3 *config.Response
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdateSecrets", []interface{}{arg1, arg2, arg3})
	fake.updateSecretsMutex.Unlock()
	if fake.UpdateSecretsStub != nil {
		return fake.UpdateSecretsStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateSecretsReturns
	return fakeReturns.result1
}

func (fake *InitializeIBPOrderer) UpdateSecretsCallCount() int {
	fake.updateSecretsMutex.RLock()
	defer fake.updateSecretsMutex.RUnlock()
	return len(fake.updateSecretsArgsForCall)
}

func (fake *InitializeIBPOrderer) UpdateSecretsCalls(stub func(common.SecretType, *v1beta1.IBPOrderer, *config.Response) error) {
	fake.updateSecretsMutex.Lock()
	defer fake.updateSecretsMutex.Unlock()
	fake.UpdateSecretsStub = stub
}

func (fake *InitializeIBPOrderer) UpdateSecretsArgsForCall(i int) (common.SecretType, *v1beta1.IBPOrderer, *config.Response) {
	fake.updateSecretsMutex.RLock()
	defer fake.updateSecretsMutex.RUnlock()
	argsForCall := fake.updateSecretsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *InitializeIBPOrderer) UpdateSecretsReturns(result1 error) {
	fake.updateSecretsMutex.Lock()
	defer fake.updateSecretsMutex.Unlock()
	fake.UpdateSecretsStub = nil
	fake.updateSecretsReturns = struct {
		result1 error
	}{result1}
}

func (fake *InitializeIBPOrderer) UpdateSecretsReturnsOnCall(i int, result1 error) {
	fake.updateSecretsMutex.Lock()
	defer fake.updateSecretsMutex.Unlock()
	fake.UpdateSecretsStub = nil
	if fake.updateSecretsReturnsOnCall == nil {
		fake.updateSecretsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateSecretsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *InitializeIBPOrderer) UpdateSecretsFromResponse(arg1 *v1beta1.IBPOrderer, arg2 *config.CryptoResponse) error {
	fake.updateSecretsFromResponseMutex.Lock()
	ret, specificReturn := fake.updateSecretsFromResponseReturnsOnCall[len(fake.updateSecretsFromResponseArgsForCall)]
	fake.updateSecretsFromResponseArgsForCall = append(fake.updateSecretsFromResponseArgsForCall, struct {
		arg1 *v1beta1.IBPOrderer
		arg2 *config.CryptoResponse
	}{arg1, arg2})
	fake.recordInvocation("UpdateSecretsFromResponse", []interface{}{arg1, arg2})
	fake.updateSecretsFromResponseMutex.Unlock()
	if fake.UpdateSecretsFromResponseStub != nil {
		return fake.UpdateSecretsFromResponseStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateSecretsFromResponseReturns
	return fakeReturns.result1
}

func (fake *InitializeIBPOrderer) UpdateSecretsFromResponseCallCount() int {
	fake.updateSecretsFromResponseMutex.RLock()
	defer fake.updateSecretsFromResponseMutex.RUnlock()
	return len(fake.updateSecretsFromResponseArgsForCall)
}

func (fake *InitializeIBPOrderer) UpdateSecretsFromResponseCalls(stub func(*v1beta1.IBPOrderer, *config.CryptoResponse) error) {
	fake.updateSecretsFromResponseMutex.Lock()
	defer fake.updateSecretsFromResponseMutex.Unlock()
	fake.UpdateSecretsFromResponseStub = stub
}

func (fake *InitializeIBPOrderer) UpdateSecretsFromResponseArgsForCall(i int) (*v1beta1.IBPOrderer, *config.CryptoResponse) {
	fake.updateSecretsFromResponseMutex.RLock()
	defer fake.updateSecretsFromResponseMutex.RUnlock()
	argsForCall := fake.updateSecretsFromResponseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *InitializeIBPOrderer) UpdateSecretsFromResponseReturns(result1 error) {
	fake.updateSecretsFromResponseMutex.Lock()
	defer fake.updateSecretsFromResponseMutex.Unlock()
	fake.UpdateSecretsFromResponseStub = nil
	fake.updateSecretsFromResponseReturns = struct {
		result1 error
	}{result1}
}

func (fake *InitializeIBPOrderer) UpdateSecretsFromResponseReturnsOnCall(i int, result1 error) {
	fake.updateSecretsFromResponseMutex.Lock()
	defer fake.updateSecretsFromResponseMutex.Unlock()
	fake.UpdateSecretsFromResponseStub = nil
	if fake.updateSecretsFromResponseReturnsOnCall == nil {
		fake.updateSecretsFromResponseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateSecretsFromResponseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *InitializeIBPOrderer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.checkIfAdminCertsUpdatedMutex.RLock()
	defer fake.checkIfAdminCertsUpdatedMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.createOrUpdateConfigMapMutex.RLock()
	defer fake.createOrUpdateConfigMapMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.generateSecretsMutex.RLock()
	defer fake.generateSecretsMutex.RUnlock()
	fake.generateSecretsFromResponseMutex.RLock()
	defer fake.generateSecretsFromResponseMutex.RUnlock()
	fake.getConfigFromConfigMapMutex.RLock()
	defer fake.getConfigFromConfigMapMutex.RUnlock()
	fake.getCoreConfigFromBytesMutex.RLock()
	defer fake.getCoreConfigFromBytesMutex.RUnlock()
	fake.getCoreConfigFromFileMutex.RLock()
	defer fake.getCoreConfigFromFileMutex.RUnlock()
	fake.getCryptoMutex.RLock()
	defer fake.getCryptoMutex.RUnlock()
	fake.getInitOrdererMutex.RLock()
	defer fake.getInitOrdererMutex.RUnlock()
	fake.getUpdatedOrdererMutex.RLock()
	defer fake.getUpdatedOrdererMutex.RUnlock()
	fake.missingCryptoMutex.RLock()
	defer fake.missingCryptoMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.updateAdminSecretMutex.RLock()
	defer fake.updateAdminSecretMutex.RUnlock()
	fake.updateSecretsMutex.RLock()
	defer fake.updateSecretsMutex.RUnlock()
	fake.updateSecretsFromResponseMutex.RLock()
	defer fake.updateSecretsFromResponseMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *InitializeIBPOrderer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ baseorderer.InitializeIBPOrderer = new(InitializeIBPOrderer)
