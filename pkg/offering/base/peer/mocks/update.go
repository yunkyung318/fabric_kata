// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/IBM-Blockchain/fabric-operator/pkg/initializer/common"
	basepeer "github.com/IBM-Blockchain/fabric-operator/pkg/offering/base/peer"
)

type Update struct {
	CertificateCreatedStub        func() bool
	certificateCreatedMutex       sync.RWMutex
	certificateCreatedArgsForCall []struct {
	}
	certificateCreatedReturns struct {
		result1 bool
	}
	certificateCreatedReturnsOnCall map[int]struct {
		result1 bool
	}
	CertificateUpdatedStub        func() bool
	certificateUpdatedMutex       sync.RWMutex
	certificateUpdatedArgsForCall []struct {
	}
	certificateUpdatedReturns struct {
		result1 bool
	}
	certificateUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	ConfigOverridesUpdatedStub        func() bool
	configOverridesUpdatedMutex       sync.RWMutex
	configOverridesUpdatedArgsForCall []struct {
	}
	configOverridesUpdatedReturns struct {
		result1 bool
	}
	configOverridesUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	CryptoBackupNeededStub        func() bool
	cryptoBackupNeededMutex       sync.RWMutex
	cryptoBackupNeededArgsForCall []struct {
	}
	cryptoBackupNeededReturns struct {
		result1 bool
	}
	cryptoBackupNeededReturnsOnCall map[int]struct {
		result1 bool
	}
	EcertEnrollStub        func() bool
	ecertEnrollMutex       sync.RWMutex
	ecertEnrollArgsForCall []struct {
	}
	ecertEnrollReturns struct {
		result1 bool
	}
	ecertEnrollReturnsOnCall map[int]struct {
		result1 bool
	}
	EcertNewKeyReenrollStub        func() bool
	ecertNewKeyReenrollMutex       sync.RWMutex
	ecertNewKeyReenrollArgsForCall []struct {
	}
	ecertNewKeyReenrollReturns struct {
		result1 bool
	}
	ecertNewKeyReenrollReturnsOnCall map[int]struct {
		result1 bool
	}
	EcertReenrollNeededStub        func() bool
	ecertReenrollNeededMutex       sync.RWMutex
	ecertReenrollNeededArgsForCall []struct {
	}
	ecertReenrollNeededReturns struct {
		result1 bool
	}
	ecertReenrollNeededReturnsOnCall map[int]struct {
		result1 bool
	}
	EcertUpdatedStub        func() bool
	ecertUpdatedMutex       sync.RWMutex
	ecertUpdatedArgsForCall []struct {
	}
	ecertUpdatedReturns struct {
		result1 bool
	}
	ecertUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	FabricVersionUpdatedStub        func() bool
	fabricVersionUpdatedMutex       sync.RWMutex
	fabricVersionUpdatedArgsForCall []struct {
	}
	fabricVersionUpdatedReturns struct {
		result1 bool
	}
	fabricVersionUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	GetCreatedCertTypeStub        func() common.SecretType
	getCreatedCertTypeMutex       sync.RWMutex
	getCreatedCertTypeArgsForCall []struct {
	}
	getCreatedCertTypeReturns struct {
		result1 common.SecretType
	}
	getCreatedCertTypeReturnsOnCall map[int]struct {
		result1 common.SecretType
	}
	ImagesUpdatedStub        func() bool
	imagesUpdatedMutex       sync.RWMutex
	imagesUpdatedArgsForCall []struct {
	}
	imagesUpdatedReturns struct {
		result1 bool
	}
	imagesUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	MSPUpdatedStub        func() bool
	mSPUpdatedMutex       sync.RWMutex
	mSPUpdatedArgsForCall []struct {
	}
	mSPUpdatedReturns struct {
		result1 bool
	}
	mSPUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	MigrateToV2Stub        func() bool
	migrateToV2Mutex       sync.RWMutex
	migrateToV2ArgsForCall []struct {
	}
	migrateToV2Returns struct {
		result1 bool
	}
	migrateToV2ReturnsOnCall map[int]struct {
		result1 bool
	}
	MigrateToV24Stub        func() bool
	migrateToV24Mutex       sync.RWMutex
	migrateToV24ArgsForCall []struct {
	}
	migrateToV24Returns struct {
		result1 bool
	}
	migrateToV24ReturnsOnCall map[int]struct {
		result1 bool
	}
	MigrateToV25Stub        func() bool
	migrateToV25Mutex       sync.RWMutex
	migrateToV25ArgsForCall []struct {
	}
	migrateToV25Returns struct {
		result1 bool
	}
	migrateToV25ReturnsOnCall map[int]struct {
		result1 bool
	}
	NodeOUUpdatedStub        func() bool
	nodeOUUpdatedMutex       sync.RWMutex
	nodeOUUpdatedArgsForCall []struct {
	}
	nodeOUUpdatedReturns struct {
		result1 bool
	}
	nodeOUUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	PeerTagUpdatedStub        func() bool
	peerTagUpdatedMutex       sync.RWMutex
	peerTagUpdatedArgsForCall []struct {
	}
	peerTagUpdatedReturns struct {
		result1 bool
	}
	peerTagUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	RestartNeededStub        func() bool
	restartNeededMutex       sync.RWMutex
	restartNeededArgsForCall []struct {
	}
	restartNeededReturns struct {
		result1 bool
	}
	restartNeededReturnsOnCall map[int]struct {
		result1 bool
	}
	SpecUpdatedStub        func() bool
	specUpdatedMutex       sync.RWMutex
	specUpdatedArgsForCall []struct {
	}
	specUpdatedReturns struct {
		result1 bool
	}
	specUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	TLSCertEnrollStub        func() bool
	tLSCertEnrollMutex       sync.RWMutex
	tLSCertEnrollArgsForCall []struct {
	}
	tLSCertEnrollReturns struct {
		result1 bool
	}
	tLSCertEnrollReturnsOnCall map[int]struct {
		result1 bool
	}
	TLSCertUpdatedStub        func() bool
	tLSCertUpdatedMutex       sync.RWMutex
	tLSCertUpdatedArgsForCall []struct {
	}
	tLSCertUpdatedReturns struct {
		result1 bool
	}
	tLSCertUpdatedReturnsOnCall map[int]struct {
		result1 bool
	}
	TLSReenrollNeededStub        func() bool
	tLSReenrollNeededMutex       sync.RWMutex
	tLSReenrollNeededArgsForCall []struct {
	}
	tLSReenrollNeededReturns struct {
		result1 bool
	}
	tLSReenrollNeededReturnsOnCall map[int]struct {
		result1 bool
	}
	TLScertNewKeyReenrollStub        func() bool
	tLScertNewKeyReenrollMutex       sync.RWMutex
	tLScertNewKeyReenrollArgsForCall []struct {
	}
	tLScertNewKeyReenrollReturns struct {
		result1 bool
	}
	tLScertNewKeyReenrollReturnsOnCall map[int]struct {
		result1 bool
	}
	UpgradeDBsStub        func() bool
	upgradeDBsMutex       sync.RWMutex
	upgradeDBsArgsForCall []struct {
	}
	upgradeDBsReturns struct {
		result1 bool
	}
	upgradeDBsReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Update) CertificateCreated() bool {
	fake.certificateCreatedMutex.Lock()
	ret, specificReturn := fake.certificateCreatedReturnsOnCall[len(fake.certificateCreatedArgsForCall)]
	fake.certificateCreatedArgsForCall = append(fake.certificateCreatedArgsForCall, struct {
	}{})
	fake.recordInvocation("CertificateCreated", []interface{}{})
	fake.certificateCreatedMutex.Unlock()
	if fake.CertificateCreatedStub != nil {
		return fake.CertificateCreatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.certificateCreatedReturns
	return fakeReturns.result1
}

func (fake *Update) CertificateCreatedCallCount() int {
	fake.certificateCreatedMutex.RLock()
	defer fake.certificateCreatedMutex.RUnlock()
	return len(fake.certificateCreatedArgsForCall)
}

func (fake *Update) CertificateCreatedCalls(stub func() bool) {
	fake.certificateCreatedMutex.Lock()
	defer fake.certificateCreatedMutex.Unlock()
	fake.CertificateCreatedStub = stub
}

func (fake *Update) CertificateCreatedReturns(result1 bool) {
	fake.certificateCreatedMutex.Lock()
	defer fake.certificateCreatedMutex.Unlock()
	fake.CertificateCreatedStub = nil
	fake.certificateCreatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) CertificateCreatedReturnsOnCall(i int, result1 bool) {
	fake.certificateCreatedMutex.Lock()
	defer fake.certificateCreatedMutex.Unlock()
	fake.CertificateCreatedStub = nil
	if fake.certificateCreatedReturnsOnCall == nil {
		fake.certificateCreatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.certificateCreatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) CertificateUpdated() bool {
	fake.certificateUpdatedMutex.Lock()
	ret, specificReturn := fake.certificateUpdatedReturnsOnCall[len(fake.certificateUpdatedArgsForCall)]
	fake.certificateUpdatedArgsForCall = append(fake.certificateUpdatedArgsForCall, struct {
	}{})
	fake.recordInvocation("CertificateUpdated", []interface{}{})
	fake.certificateUpdatedMutex.Unlock()
	if fake.CertificateUpdatedStub != nil {
		return fake.CertificateUpdatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.certificateUpdatedReturns
	return fakeReturns.result1
}

func (fake *Update) CertificateUpdatedCallCount() int {
	fake.certificateUpdatedMutex.RLock()
	defer fake.certificateUpdatedMutex.RUnlock()
	return len(fake.certificateUpdatedArgsForCall)
}

func (fake *Update) CertificateUpdatedCalls(stub func() bool) {
	fake.certificateUpdatedMutex.Lock()
	defer fake.certificateUpdatedMutex.Unlock()
	fake.CertificateUpdatedStub = stub
}

func (fake *Update) CertificateUpdatedReturns(result1 bool) {
	fake.certificateUpdatedMutex.Lock()
	defer fake.certificateUpdatedMutex.Unlock()
	fake.CertificateUpdatedStub = nil
	fake.certificateUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) CertificateUpdatedReturnsOnCall(i int, result1 bool) {
	fake.certificateUpdatedMutex.Lock()
	defer fake.certificateUpdatedMutex.Unlock()
	fake.CertificateUpdatedStub = nil
	if fake.certificateUpdatedReturnsOnCall == nil {
		fake.certificateUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.certificateUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) ConfigOverridesUpdated() bool {
	fake.configOverridesUpdatedMutex.Lock()
	ret, specificReturn := fake.configOverridesUpdatedReturnsOnCall[len(fake.configOverridesUpdatedArgsForCall)]
	fake.configOverridesUpdatedArgsForCall = append(fake.configOverridesUpdatedArgsForCall, struct {
	}{})
	fake.recordInvocation("ConfigOverridesUpdated", []interface{}{})
	fake.configOverridesUpdatedMutex.Unlock()
	if fake.ConfigOverridesUpdatedStub != nil {
		return fake.ConfigOverridesUpdatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.configOverridesUpdatedReturns
	return fakeReturns.result1
}

func (fake *Update) ConfigOverridesUpdatedCallCount() int {
	fake.configOverridesUpdatedMutex.RLock()
	defer fake.configOverridesUpdatedMutex.RUnlock()
	return len(fake.configOverridesUpdatedArgsForCall)
}

func (fake *Update) ConfigOverridesUpdatedCalls(stub func() bool) {
	fake.configOverridesUpdatedMutex.Lock()
	defer fake.configOverridesUpdatedMutex.Unlock()
	fake.ConfigOverridesUpdatedStub = stub
}

func (fake *Update) ConfigOverridesUpdatedReturns(result1 bool) {
	fake.configOverridesUpdatedMutex.Lock()
	defer fake.configOverridesUpdatedMutex.Unlock()
	fake.ConfigOverridesUpdatedStub = nil
	fake.configOverridesUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) ConfigOverridesUpdatedReturnsOnCall(i int, result1 bool) {
	fake.configOverridesUpdatedMutex.Lock()
	defer fake.configOverridesUpdatedMutex.Unlock()
	fake.ConfigOverridesUpdatedStub = nil
	if fake.configOverridesUpdatedReturnsOnCall == nil {
		fake.configOverridesUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.configOverridesUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) CryptoBackupNeeded() bool {
	fake.cryptoBackupNeededMutex.Lock()
	ret, specificReturn := fake.cryptoBackupNeededReturnsOnCall[len(fake.cryptoBackupNeededArgsForCall)]
	fake.cryptoBackupNeededArgsForCall = append(fake.cryptoBackupNeededArgsForCall, struct {
	}{})
	fake.recordInvocation("CryptoBackupNeeded", []interface{}{})
	fake.cryptoBackupNeededMutex.Unlock()
	if fake.CryptoBackupNeededStub != nil {
		return fake.CryptoBackupNeededStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cryptoBackupNeededReturns
	return fakeReturns.result1
}

func (fake *Update) CryptoBackupNeededCallCount() int {
	fake.cryptoBackupNeededMutex.RLock()
	defer fake.cryptoBackupNeededMutex.RUnlock()
	return len(fake.cryptoBackupNeededArgsForCall)
}

func (fake *Update) CryptoBackupNeededCalls(stub func() bool) {
	fake.cryptoBackupNeededMutex.Lock()
	defer fake.cryptoBackupNeededMutex.Unlock()
	fake.CryptoBackupNeededStub = stub
}

func (fake *Update) CryptoBackupNeededReturns(result1 bool) {
	fake.cryptoBackupNeededMutex.Lock()
	defer fake.cryptoBackupNeededMutex.Unlock()
	fake.CryptoBackupNeededStub = nil
	fake.cryptoBackupNeededReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) CryptoBackupNeededReturnsOnCall(i int, result1 bool) {
	fake.cryptoBackupNeededMutex.Lock()
	defer fake.cryptoBackupNeededMutex.Unlock()
	fake.CryptoBackupNeededStub = nil
	if fake.cryptoBackupNeededReturnsOnCall == nil {
		fake.cryptoBackupNeededReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.cryptoBackupNeededReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) EcertEnroll() bool {
	fake.ecertEnrollMutex.Lock()
	ret, specificReturn := fake.ecertEnrollReturnsOnCall[len(fake.ecertEnrollArgsForCall)]
	fake.ecertEnrollArgsForCall = append(fake.ecertEnrollArgsForCall, struct {
	}{})
	fake.recordInvocation("EcertEnroll", []interface{}{})
	fake.ecertEnrollMutex.Unlock()
	if fake.EcertEnrollStub != nil {
		return fake.EcertEnrollStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.ecertEnrollReturns
	return fakeReturns.result1
}

func (fake *Update) EcertEnrollCallCount() int {
	fake.ecertEnrollMutex.RLock()
	defer fake.ecertEnrollMutex.RUnlock()
	return len(fake.ecertEnrollArgsForCall)
}

func (fake *Update) EcertEnrollCalls(stub func() bool) {
	fake.ecertEnrollMutex.Lock()
	defer fake.ecertEnrollMutex.Unlock()
	fake.EcertEnrollStub = stub
}

func (fake *Update) EcertEnrollReturns(result1 bool) {
	fake.ecertEnrollMutex.Lock()
	defer fake.ecertEnrollMutex.Unlock()
	fake.EcertEnrollStub = nil
	fake.ecertEnrollReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) EcertEnrollReturnsOnCall(i int, result1 bool) {
	fake.ecertEnrollMutex.Lock()
	defer fake.ecertEnrollMutex.Unlock()
	fake.EcertEnrollStub = nil
	if fake.ecertEnrollReturnsOnCall == nil {
		fake.ecertEnrollReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.ecertEnrollReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) EcertNewKeyReenroll() bool {
	fake.ecertNewKeyReenrollMutex.Lock()
	ret, specificReturn := fake.ecertNewKeyReenrollReturnsOnCall[len(fake.ecertNewKeyReenrollArgsForCall)]
	fake.ecertNewKeyReenrollArgsForCall = append(fake.ecertNewKeyReenrollArgsForCall, struct {
	}{})
	fake.recordInvocation("EcertNewKeyReenroll", []interface{}{})
	fake.ecertNewKeyReenrollMutex.Unlock()
	if fake.EcertNewKeyReenrollStub != nil {
		return fake.EcertNewKeyReenrollStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.ecertNewKeyReenrollReturns
	return fakeReturns.result1
}

func (fake *Update) EcertNewKeyReenrollCallCount() int {
	fake.ecertNewKeyReenrollMutex.RLock()
	defer fake.ecertNewKeyReenrollMutex.RUnlock()
	return len(fake.ecertNewKeyReenrollArgsForCall)
}

func (fake *Update) EcertNewKeyReenrollCalls(stub func() bool) {
	fake.ecertNewKeyReenrollMutex.Lock()
	defer fake.ecertNewKeyReenrollMutex.Unlock()
	fake.EcertNewKeyReenrollStub = stub
}

func (fake *Update) EcertNewKeyReenrollReturns(result1 bool) {
	fake.ecertNewKeyReenrollMutex.Lock()
	defer fake.ecertNewKeyReenrollMutex.Unlock()
	fake.EcertNewKeyReenrollStub = nil
	fake.ecertNewKeyReenrollReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) EcertNewKeyReenrollReturnsOnCall(i int, result1 bool) {
	fake.ecertNewKeyReenrollMutex.Lock()
	defer fake.ecertNewKeyReenrollMutex.Unlock()
	fake.EcertNewKeyReenrollStub = nil
	if fake.ecertNewKeyReenrollReturnsOnCall == nil {
		fake.ecertNewKeyReenrollReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.ecertNewKeyReenrollReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) EcertReenrollNeeded() bool {
	fake.ecertReenrollNeededMutex.Lock()
	ret, specificReturn := fake.ecertReenrollNeededReturnsOnCall[len(fake.ecertReenrollNeededArgsForCall)]
	fake.ecertReenrollNeededArgsForCall = append(fake.ecertReenrollNeededArgsForCall, struct {
	}{})
	fake.recordInvocation("EcertReenrollNeeded", []interface{}{})
	fake.ecertReenrollNeededMutex.Unlock()
	if fake.EcertReenrollNeededStub != nil {
		return fake.EcertReenrollNeededStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.ecertReenrollNeededReturns
	return fakeReturns.result1
}

func (fake *Update) EcertReenrollNeededCallCount() int {
	fake.ecertReenrollNeededMutex.RLock()
	defer fake.ecertReenrollNeededMutex.RUnlock()
	return len(fake.ecertReenrollNeededArgsForCall)
}

func (fake *Update) EcertReenrollNeededCalls(stub func() bool) {
	fake.ecertReenrollNeededMutex.Lock()
	defer fake.ecertReenrollNeededMutex.Unlock()
	fake.EcertReenrollNeededStub = stub
}

func (fake *Update) EcertReenrollNeededReturns(result1 bool) {
	fake.ecertReenrollNeededMutex.Lock()
	defer fake.ecertReenrollNeededMutex.Unlock()
	fake.EcertReenrollNeededStub = nil
	fake.ecertReenrollNeededReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) EcertReenrollNeededReturnsOnCall(i int, result1 bool) {
	fake.ecertReenrollNeededMutex.Lock()
	defer fake.ecertReenrollNeededMutex.Unlock()
	fake.EcertReenrollNeededStub = nil
	if fake.ecertReenrollNeededReturnsOnCall == nil {
		fake.ecertReenrollNeededReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.ecertReenrollNeededReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) EcertUpdated() bool {
	fake.ecertUpdatedMutex.Lock()
	ret, specificReturn := fake.ecertUpdatedReturnsOnCall[len(fake.ecertUpdatedArgsForCall)]
	fake.ecertUpdatedArgsForCall = append(fake.ecertUpdatedArgsForCall, struct {
	}{})
	fake.recordInvocation("EcertUpdated", []interface{}{})
	fake.ecertUpdatedMutex.Unlock()
	if fake.EcertUpdatedStub != nil {
		return fake.EcertUpdatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.ecertUpdatedReturns
	return fakeReturns.result1
}

func (fake *Update) EcertUpdatedCallCount() int {
	fake.ecertUpdatedMutex.RLock()
	defer fake.ecertUpdatedMutex.RUnlock()
	return len(fake.ecertUpdatedArgsForCall)
}

func (fake *Update) EcertUpdatedCalls(stub func() bool) {
	fake.ecertUpdatedMutex.Lock()
	defer fake.ecertUpdatedMutex.Unlock()
	fake.EcertUpdatedStub = stub
}

func (fake *Update) EcertUpdatedReturns(result1 bool) {
	fake.ecertUpdatedMutex.Lock()
	defer fake.ecertUpdatedMutex.Unlock()
	fake.EcertUpdatedStub = nil
	fake.ecertUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) EcertUpdatedReturnsOnCall(i int, result1 bool) {
	fake.ecertUpdatedMutex.Lock()
	defer fake.ecertUpdatedMutex.Unlock()
	fake.EcertUpdatedStub = nil
	if fake.ecertUpdatedReturnsOnCall == nil {
		fake.ecertUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.ecertUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) FabricVersionUpdated() bool {
	fake.fabricVersionUpdatedMutex.Lock()
	ret, specificReturn := fake.fabricVersionUpdatedReturnsOnCall[len(fake.fabricVersionUpdatedArgsForCall)]
	fake.fabricVersionUpdatedArgsForCall = append(fake.fabricVersionUpdatedArgsForCall, struct {
	}{})
	fake.recordInvocation("FabricVersionUpdated", []interface{}{})
	fake.fabricVersionUpdatedMutex.Unlock()
	if fake.FabricVersionUpdatedStub != nil {
		return fake.FabricVersionUpdatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.fabricVersionUpdatedReturns
	return fakeReturns.result1
}

func (fake *Update) FabricVersionUpdatedCallCount() int {
	fake.fabricVersionUpdatedMutex.RLock()
	defer fake.fabricVersionUpdatedMutex.RUnlock()
	return len(fake.fabricVersionUpdatedArgsForCall)
}

func (fake *Update) FabricVersionUpdatedCalls(stub func() bool) {
	fake.fabricVersionUpdatedMutex.Lock()
	defer fake.fabricVersionUpdatedMutex.Unlock()
	fake.FabricVersionUpdatedStub = stub
}

func (fake *Update) FabricVersionUpdatedReturns(result1 bool) {
	fake.fabricVersionUpdatedMutex.Lock()
	defer fake.fabricVersionUpdatedMutex.Unlock()
	fake.FabricVersionUpdatedStub = nil
	fake.fabricVersionUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) FabricVersionUpdatedReturnsOnCall(i int, result1 bool) {
	fake.fabricVersionUpdatedMutex.Lock()
	defer fake.fabricVersionUpdatedMutex.Unlock()
	fake.FabricVersionUpdatedStub = nil
	if fake.fabricVersionUpdatedReturnsOnCall == nil {
		fake.fabricVersionUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.fabricVersionUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) GetCreatedCertType() common.SecretType {
	fake.getCreatedCertTypeMutex.Lock()
	ret, specificReturn := fake.getCreatedCertTypeReturnsOnCall[len(fake.getCreatedCertTypeArgsForCall)]
	fake.getCreatedCertTypeArgsForCall = append(fake.getCreatedCertTypeArgsForCall, struct {
	}{})
	fake.recordInvocation("GetCreatedCertType", []interface{}{})
	fake.getCreatedCertTypeMutex.Unlock()
	if fake.GetCreatedCertTypeStub != nil {
		return fake.GetCreatedCertTypeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getCreatedCertTypeReturns
	return fakeReturns.result1
}

func (fake *Update) GetCreatedCertTypeCallCount() int {
	fake.getCreatedCertTypeMutex.RLock()
	defer fake.getCreatedCertTypeMutex.RUnlock()
	return len(fake.getCreatedCertTypeArgsForCall)
}

func (fake *Update) GetCreatedCertTypeCalls(stub func() common.SecretType) {
	fake.getCreatedCertTypeMutex.Lock()
	defer fake.getCreatedCertTypeMutex.Unlock()
	fake.GetCreatedCertTypeStub = stub
}

func (fake *Update) GetCreatedCertTypeReturns(result1 common.SecretType) {
	fake.getCreatedCertTypeMutex.Lock()
	defer fake.getCreatedCertTypeMutex.Unlock()
	fake.GetCreatedCertTypeStub = nil
	fake.getCreatedCertTypeReturns = struct {
		result1 common.SecretType
	}{result1}
}

func (fake *Update) GetCreatedCertTypeReturnsOnCall(i int, result1 common.SecretType) {
	fake.getCreatedCertTypeMutex.Lock()
	defer fake.getCreatedCertTypeMutex.Unlock()
	fake.GetCreatedCertTypeStub = nil
	if fake.getCreatedCertTypeReturnsOnCall == nil {
		fake.getCreatedCertTypeReturnsOnCall = make(map[int]struct {
			result1 common.SecretType
		})
	}
	fake.getCreatedCertTypeReturnsOnCall[i] = struct {
		result1 common.SecretType
	}{result1}
}

func (fake *Update) ImagesUpdated() bool {
	fake.imagesUpdatedMutex.Lock()
	ret, specificReturn := fake.imagesUpdatedReturnsOnCall[len(fake.imagesUpdatedArgsForCall)]
	fake.imagesUpdatedArgsForCall = append(fake.imagesUpdatedArgsForCall, struct {
	}{})
	fake.recordInvocation("ImagesUpdated", []interface{}{})
	fake.imagesUpdatedMutex.Unlock()
	if fake.ImagesUpdatedStub != nil {
		return fake.ImagesUpdatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.imagesUpdatedReturns
	return fakeReturns.result1
}

func (fake *Update) ImagesUpdatedCallCount() int {
	fake.imagesUpdatedMutex.RLock()
	defer fake.imagesUpdatedMutex.RUnlock()
	return len(fake.imagesUpdatedArgsForCall)
}

func (fake *Update) ImagesUpdatedCalls(stub func() bool) {
	fake.imagesUpdatedMutex.Lock()
	defer fake.imagesUpdatedMutex.Unlock()
	fake.ImagesUpdatedStub = stub
}

func (fake *Update) ImagesUpdatedReturns(result1 bool) {
	fake.imagesUpdatedMutex.Lock()
	defer fake.imagesUpdatedMutex.Unlock()
	fake.ImagesUpdatedStub = nil
	fake.imagesUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) ImagesUpdatedReturnsOnCall(i int, result1 bool) {
	fake.imagesUpdatedMutex.Lock()
	defer fake.imagesUpdatedMutex.Unlock()
	fake.ImagesUpdatedStub = nil
	if fake.imagesUpdatedReturnsOnCall == nil {
		fake.imagesUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.imagesUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) MSPUpdated() bool {
	fake.mSPUpdatedMutex.Lock()
	ret, specificReturn := fake.mSPUpdatedReturnsOnCall[len(fake.mSPUpdatedArgsForCall)]
	fake.mSPUpdatedArgsForCall = append(fake.mSPUpdatedArgsForCall, struct {
	}{})
	fake.recordInvocation("MSPUpdated", []interface{}{})
	fake.mSPUpdatedMutex.Unlock()
	if fake.MSPUpdatedStub != nil {
		return fake.MSPUpdatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.mSPUpdatedReturns
	return fakeReturns.result1
}

func (fake *Update) MSPUpdatedCallCount() int {
	fake.mSPUpdatedMutex.RLock()
	defer fake.mSPUpdatedMutex.RUnlock()
	return len(fake.mSPUpdatedArgsForCall)
}

func (fake *Update) MSPUpdatedCalls(stub func() bool) {
	fake.mSPUpdatedMutex.Lock()
	defer fake.mSPUpdatedMutex.Unlock()
	fake.MSPUpdatedStub = stub
}

func (fake *Update) MSPUpdatedReturns(result1 bool) {
	fake.mSPUpdatedMutex.Lock()
	defer fake.mSPUpdatedMutex.Unlock()
	fake.MSPUpdatedStub = nil
	fake.mSPUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) MSPUpdatedReturnsOnCall(i int, result1 bool) {
	fake.mSPUpdatedMutex.Lock()
	defer fake.mSPUpdatedMutex.Unlock()
	fake.MSPUpdatedStub = nil
	if fake.mSPUpdatedReturnsOnCall == nil {
		fake.mSPUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.mSPUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) MigrateToV2() bool {
	fake.migrateToV2Mutex.Lock()
	ret, specificReturn := fake.migrateToV2ReturnsOnCall[len(fake.migrateToV2ArgsForCall)]
	fake.migrateToV2ArgsForCall = append(fake.migrateToV2ArgsForCall, struct {
	}{})
	fake.recordInvocation("MigrateToV2", []interface{}{})
	fake.migrateToV2Mutex.Unlock()
	if fake.MigrateToV2Stub != nil {
		return fake.MigrateToV2Stub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.migrateToV2Returns
	return fakeReturns.result1
}

func (fake *Update) MigrateToV2CallCount() int {
	fake.migrateToV2Mutex.RLock()
	defer fake.migrateToV2Mutex.RUnlock()
	return len(fake.migrateToV2ArgsForCall)
}

func (fake *Update) MigrateToV2Calls(stub func() bool) {
	fake.migrateToV2Mutex.Lock()
	defer fake.migrateToV2Mutex.Unlock()
	fake.MigrateToV2Stub = stub
}

func (fake *Update) MigrateToV2Returns(result1 bool) {
	fake.migrateToV2Mutex.Lock()
	defer fake.migrateToV2Mutex.Unlock()
	fake.MigrateToV2Stub = nil
	fake.migrateToV2Returns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) MigrateToV2ReturnsOnCall(i int, result1 bool) {
	fake.migrateToV2Mutex.Lock()
	defer fake.migrateToV2Mutex.Unlock()
	fake.MigrateToV2Stub = nil
	if fake.migrateToV2ReturnsOnCall == nil {
		fake.migrateToV2ReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.migrateToV2ReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) MigrateToV24() bool {
	fake.migrateToV24Mutex.Lock()
	ret, specificReturn := fake.migrateToV24ReturnsOnCall[len(fake.migrateToV24ArgsForCall)]
	fake.migrateToV24ArgsForCall = append(fake.migrateToV24ArgsForCall, struct {
	}{})
	fake.recordInvocation("MigrateToV24", []interface{}{})
	fake.migrateToV24Mutex.Unlock()
	if fake.MigrateToV24Stub != nil {
		return fake.MigrateToV24Stub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.migrateToV24Returns
	return fakeReturns.result1
}

func (fake *Update) MigrateToV24CallCount() int {
	fake.migrateToV24Mutex.RLock()
	defer fake.migrateToV24Mutex.RUnlock()
	return len(fake.migrateToV24ArgsForCall)
}

func (fake *Update) MigrateToV24Calls(stub func() bool) {
	fake.migrateToV24Mutex.Lock()
	defer fake.migrateToV24Mutex.Unlock()
	fake.MigrateToV24Stub = stub
}

func (fake *Update) MigrateToV24Returns(result1 bool) {
	fake.migrateToV24Mutex.Lock()
	defer fake.migrateToV24Mutex.Unlock()
	fake.MigrateToV24Stub = nil
	fake.migrateToV24Returns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) MigrateToV24ReturnsOnCall(i int, result1 bool) {
	fake.migrateToV24Mutex.Lock()
	defer fake.migrateToV24Mutex.Unlock()
	fake.MigrateToV24Stub = nil
	if fake.migrateToV24ReturnsOnCall == nil {
		fake.migrateToV24ReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.migrateToV24ReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) MigrateToV25() bool {
	fake.migrateToV25Mutex.Lock()
	ret, specificReturn := fake.migrateToV25ReturnsOnCall[len(fake.migrateToV25ArgsForCall)]
	fake.migrateToV25ArgsForCall = append(fake.migrateToV25ArgsForCall, struct {
	}{})
	fake.recordInvocation("MigrateToV25", []interface{}{})
	fake.migrateToV25Mutex.Unlock()
	if fake.MigrateToV25Stub != nil {
		return fake.MigrateToV25Stub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.migrateToV25Returns
	return fakeReturns.result1
}

func (fake *Update) MigrateToV25CallCount() int {
	fake.migrateToV25Mutex.RLock()
	defer fake.migrateToV25Mutex.RUnlock()
	return len(fake.migrateToV25ArgsForCall)
}

func (fake *Update) MigrateToV25Calls(stub func() bool) {
	fake.migrateToV25Mutex.Lock()
	defer fake.migrateToV25Mutex.Unlock()
	fake.MigrateToV25Stub = stub
}

func (fake *Update) MigrateToV25Returns(result1 bool) {
	fake.migrateToV25Mutex.Lock()
	defer fake.migrateToV25Mutex.Unlock()
	fake.MigrateToV25Stub = nil
	fake.migrateToV25Returns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) MigrateToV25ReturnsOnCall(i int, result1 bool) {
	fake.migrateToV25Mutex.Lock()
	defer fake.migrateToV25Mutex.Unlock()
	fake.MigrateToV25Stub = nil
	if fake.migrateToV25ReturnsOnCall == nil {
		fake.migrateToV25ReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.migrateToV25ReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) NodeOUUpdated() bool {
	fake.nodeOUUpdatedMutex.Lock()
	ret, specificReturn := fake.nodeOUUpdatedReturnsOnCall[len(fake.nodeOUUpdatedArgsForCall)]
	fake.nodeOUUpdatedArgsForCall = append(fake.nodeOUUpdatedArgsForCall, struct {
	}{})
	fake.recordInvocation("NodeOUUpdated", []interface{}{})
	fake.nodeOUUpdatedMutex.Unlock()
	if fake.NodeOUUpdatedStub != nil {
		return fake.NodeOUUpdatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.nodeOUUpdatedReturns
	return fakeReturns.result1
}

func (fake *Update) NodeOUUpdatedCallCount() int {
	fake.nodeOUUpdatedMutex.RLock()
	defer fake.nodeOUUpdatedMutex.RUnlock()
	return len(fake.nodeOUUpdatedArgsForCall)
}

func (fake *Update) NodeOUUpdatedCalls(stub func() bool) {
	fake.nodeOUUpdatedMutex.Lock()
	defer fake.nodeOUUpdatedMutex.Unlock()
	fake.NodeOUUpdatedStub = stub
}

func (fake *Update) NodeOUUpdatedReturns(result1 bool) {
	fake.nodeOUUpdatedMutex.Lock()
	defer fake.nodeOUUpdatedMutex.Unlock()
	fake.NodeOUUpdatedStub = nil
	fake.nodeOUUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) NodeOUUpdatedReturnsOnCall(i int, result1 bool) {
	fake.nodeOUUpdatedMutex.Lock()
	defer fake.nodeOUUpdatedMutex.Unlock()
	fake.NodeOUUpdatedStub = nil
	if fake.nodeOUUpdatedReturnsOnCall == nil {
		fake.nodeOUUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.nodeOUUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) PeerTagUpdated() bool {
	fake.peerTagUpdatedMutex.Lock()
	ret, specificReturn := fake.peerTagUpdatedReturnsOnCall[len(fake.peerTagUpdatedArgsForCall)]
	fake.peerTagUpdatedArgsForCall = append(fake.peerTagUpdatedArgsForCall, struct {
	}{})
	fake.recordInvocation("PeerTagUpdated", []interface{}{})
	fake.peerTagUpdatedMutex.Unlock()
	if fake.PeerTagUpdatedStub != nil {
		return fake.PeerTagUpdatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.peerTagUpdatedReturns
	return fakeReturns.result1
}

func (fake *Update) PeerTagUpdatedCallCount() int {
	fake.peerTagUpdatedMutex.RLock()
	defer fake.peerTagUpdatedMutex.RUnlock()
	return len(fake.peerTagUpdatedArgsForCall)
}

func (fake *Update) PeerTagUpdatedCalls(stub func() bool) {
	fake.peerTagUpdatedMutex.Lock()
	defer fake.peerTagUpdatedMutex.Unlock()
	fake.PeerTagUpdatedStub = stub
}

func (fake *Update) PeerTagUpdatedReturns(result1 bool) {
	fake.peerTagUpdatedMutex.Lock()
	defer fake.peerTagUpdatedMutex.Unlock()
	fake.PeerTagUpdatedStub = nil
	fake.peerTagUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) PeerTagUpdatedReturnsOnCall(i int, result1 bool) {
	fake.peerTagUpdatedMutex.Lock()
	defer fake.peerTagUpdatedMutex.Unlock()
	fake.PeerTagUpdatedStub = nil
	if fake.peerTagUpdatedReturnsOnCall == nil {
		fake.peerTagUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.peerTagUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) RestartNeeded() bool {
	fake.restartNeededMutex.Lock()
	ret, specificReturn := fake.restartNeededReturnsOnCall[len(fake.restartNeededArgsForCall)]
	fake.restartNeededArgsForCall = append(fake.restartNeededArgsForCall, struct {
	}{})
	fake.recordInvocation("RestartNeeded", []interface{}{})
	fake.restartNeededMutex.Unlock()
	if fake.RestartNeededStub != nil {
		return fake.RestartNeededStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.restartNeededReturns
	return fakeReturns.result1
}

func (fake *Update) RestartNeededCallCount() int {
	fake.restartNeededMutex.RLock()
	defer fake.restartNeededMutex.RUnlock()
	return len(fake.restartNeededArgsForCall)
}

func (fake *Update) RestartNeededCalls(stub func() bool) {
	fake.restartNeededMutex.Lock()
	defer fake.restartNeededMutex.Unlock()
	fake.RestartNeededStub = stub
}

func (fake *Update) RestartNeededReturns(result1 bool) {
	fake.restartNeededMutex.Lock()
	defer fake.restartNeededMutex.Unlock()
	fake.RestartNeededStub = nil
	fake.restartNeededReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) RestartNeededReturnsOnCall(i int, result1 bool) {
	fake.restartNeededMutex.Lock()
	defer fake.restartNeededMutex.Unlock()
	fake.RestartNeededStub = nil
	if fake.restartNeededReturnsOnCall == nil {
		fake.restartNeededReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.restartNeededReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) SpecUpdated() bool {
	fake.specUpdatedMutex.Lock()
	ret, specificReturn := fake.specUpdatedReturnsOnCall[len(fake.specUpdatedArgsForCall)]
	fake.specUpdatedArgsForCall = append(fake.specUpdatedArgsForCall, struct {
	}{})
	fake.recordInvocation("SpecUpdated", []interface{}{})
	fake.specUpdatedMutex.Unlock()
	if fake.SpecUpdatedStub != nil {
		return fake.SpecUpdatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.specUpdatedReturns
	return fakeReturns.result1
}

func (fake *Update) SpecUpdatedCallCount() int {
	fake.specUpdatedMutex.RLock()
	defer fake.specUpdatedMutex.RUnlock()
	return len(fake.specUpdatedArgsForCall)
}

func (fake *Update) SpecUpdatedCalls(stub func() bool) {
	fake.specUpdatedMutex.Lock()
	defer fake.specUpdatedMutex.Unlock()
	fake.SpecUpdatedStub = stub
}

func (fake *Update) SpecUpdatedReturns(result1 bool) {
	fake.specUpdatedMutex.Lock()
	defer fake.specUpdatedMutex.Unlock()
	fake.SpecUpdatedStub = nil
	fake.specUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) SpecUpdatedReturnsOnCall(i int, result1 bool) {
	fake.specUpdatedMutex.Lock()
	defer fake.specUpdatedMutex.Unlock()
	fake.SpecUpdatedStub = nil
	if fake.specUpdatedReturnsOnCall == nil {
		fake.specUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.specUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) TLSCertEnroll() bool {
	fake.tLSCertEnrollMutex.Lock()
	ret, specificReturn := fake.tLSCertEnrollReturnsOnCall[len(fake.tLSCertEnrollArgsForCall)]
	fake.tLSCertEnrollArgsForCall = append(fake.tLSCertEnrollArgsForCall, struct {
	}{})
	fake.recordInvocation("TLSCertEnroll", []interface{}{})
	fake.tLSCertEnrollMutex.Unlock()
	if fake.TLSCertEnrollStub != nil {
		return fake.TLSCertEnrollStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.tLSCertEnrollReturns
	return fakeReturns.result1
}

func (fake *Update) TLSCertEnrollCallCount() int {
	fake.tLSCertEnrollMutex.RLock()
	defer fake.tLSCertEnrollMutex.RUnlock()
	return len(fake.tLSCertEnrollArgsForCall)
}

func (fake *Update) TLSCertEnrollCalls(stub func() bool) {
	fake.tLSCertEnrollMutex.Lock()
	defer fake.tLSCertEnrollMutex.Unlock()
	fake.TLSCertEnrollStub = stub
}

func (fake *Update) TLSCertEnrollReturns(result1 bool) {
	fake.tLSCertEnrollMutex.Lock()
	defer fake.tLSCertEnrollMutex.Unlock()
	fake.TLSCertEnrollStub = nil
	fake.tLSCertEnrollReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) TLSCertEnrollReturnsOnCall(i int, result1 bool) {
	fake.tLSCertEnrollMutex.Lock()
	defer fake.tLSCertEnrollMutex.Unlock()
	fake.TLSCertEnrollStub = nil
	if fake.tLSCertEnrollReturnsOnCall == nil {
		fake.tLSCertEnrollReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.tLSCertEnrollReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) TLSCertUpdated() bool {
	fake.tLSCertUpdatedMutex.Lock()
	ret, specificReturn := fake.tLSCertUpdatedReturnsOnCall[len(fake.tLSCertUpdatedArgsForCall)]
	fake.tLSCertUpdatedArgsForCall = append(fake.tLSCertUpdatedArgsForCall, struct {
	}{})
	fake.recordInvocation("TLSCertUpdated", []interface{}{})
	fake.tLSCertUpdatedMutex.Unlock()
	if fake.TLSCertUpdatedStub != nil {
		return fake.TLSCertUpdatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.tLSCertUpdatedReturns
	return fakeReturns.result1
}

func (fake *Update) TLSCertUpdatedCallCount() int {
	fake.tLSCertUpdatedMutex.RLock()
	defer fake.tLSCertUpdatedMutex.RUnlock()
	return len(fake.tLSCertUpdatedArgsForCall)
}

func (fake *Update) TLSCertUpdatedCalls(stub func() bool) {
	fake.tLSCertUpdatedMutex.Lock()
	defer fake.tLSCertUpdatedMutex.Unlock()
	fake.TLSCertUpdatedStub = stub
}

func (fake *Update) TLSCertUpdatedReturns(result1 bool) {
	fake.tLSCertUpdatedMutex.Lock()
	defer fake.tLSCertUpdatedMutex.Unlock()
	fake.TLSCertUpdatedStub = nil
	fake.tLSCertUpdatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) TLSCertUpdatedReturnsOnCall(i int, result1 bool) {
	fake.tLSCertUpdatedMutex.Lock()
	defer fake.tLSCertUpdatedMutex.Unlock()
	fake.TLSCertUpdatedStub = nil
	if fake.tLSCertUpdatedReturnsOnCall == nil {
		fake.tLSCertUpdatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.tLSCertUpdatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) TLSReenrollNeeded() bool {
	fake.tLSReenrollNeededMutex.Lock()
	ret, specificReturn := fake.tLSReenrollNeededReturnsOnCall[len(fake.tLSReenrollNeededArgsForCall)]
	fake.tLSReenrollNeededArgsForCall = append(fake.tLSReenrollNeededArgsForCall, struct {
	}{})
	fake.recordInvocation("TLSReenrollNeeded", []interface{}{})
	fake.tLSReenrollNeededMutex.Unlock()
	if fake.TLSReenrollNeededStub != nil {
		return fake.TLSReenrollNeededStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.tLSReenrollNeededReturns
	return fakeReturns.result1
}

func (fake *Update) TLSReenrollNeededCallCount() int {
	fake.tLSReenrollNeededMutex.RLock()
	defer fake.tLSReenrollNeededMutex.RUnlock()
	return len(fake.tLSReenrollNeededArgsForCall)
}

func (fake *Update) TLSReenrollNeededCalls(stub func() bool) {
	fake.tLSReenrollNeededMutex.Lock()
	defer fake.tLSReenrollNeededMutex.Unlock()
	fake.TLSReenrollNeededStub = stub
}

func (fake *Update) TLSReenrollNeededReturns(result1 bool) {
	fake.tLSReenrollNeededMutex.Lock()
	defer fake.tLSReenrollNeededMutex.Unlock()
	fake.TLSReenrollNeededStub = nil
	fake.tLSReenrollNeededReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) TLSReenrollNeededReturnsOnCall(i int, result1 bool) {
	fake.tLSReenrollNeededMutex.Lock()
	defer fake.tLSReenrollNeededMutex.Unlock()
	fake.TLSReenrollNeededStub = nil
	if fake.tLSReenrollNeededReturnsOnCall == nil {
		fake.tLSReenrollNeededReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.tLSReenrollNeededReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) TLScertNewKeyReenroll() bool {
	fake.tLScertNewKeyReenrollMutex.Lock()
	ret, specificReturn := fake.tLScertNewKeyReenrollReturnsOnCall[len(fake.tLScertNewKeyReenrollArgsForCall)]
	fake.tLScertNewKeyReenrollArgsForCall = append(fake.tLScertNewKeyReenrollArgsForCall, struct {
	}{})
	fake.recordInvocation("TLScertNewKeyReenroll", []interface{}{})
	fake.tLScertNewKeyReenrollMutex.Unlock()
	if fake.TLScertNewKeyReenrollStub != nil {
		return fake.TLScertNewKeyReenrollStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.tLScertNewKeyReenrollReturns
	return fakeReturns.result1
}

func (fake *Update) TLScertNewKeyReenrollCallCount() int {
	fake.tLScertNewKeyReenrollMutex.RLock()
	defer fake.tLScertNewKeyReenrollMutex.RUnlock()
	return len(fake.tLScertNewKeyReenrollArgsForCall)
}

func (fake *Update) TLScertNewKeyReenrollCalls(stub func() bool) {
	fake.tLScertNewKeyReenrollMutex.Lock()
	defer fake.tLScertNewKeyReenrollMutex.Unlock()
	fake.TLScertNewKeyReenrollStub = stub
}

func (fake *Update) TLScertNewKeyReenrollReturns(result1 bool) {
	fake.tLScertNewKeyReenrollMutex.Lock()
	defer fake.tLScertNewKeyReenrollMutex.Unlock()
	fake.TLScertNewKeyReenrollStub = nil
	fake.tLScertNewKeyReenrollReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) TLScertNewKeyReenrollReturnsOnCall(i int, result1 bool) {
	fake.tLScertNewKeyReenrollMutex.Lock()
	defer fake.tLScertNewKeyReenrollMutex.Unlock()
	fake.TLScertNewKeyReenrollStub = nil
	if fake.tLScertNewKeyReenrollReturnsOnCall == nil {
		fake.tLScertNewKeyReenrollReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.tLScertNewKeyReenrollReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) UpgradeDBs() bool {
	fake.upgradeDBsMutex.Lock()
	ret, specificReturn := fake.upgradeDBsReturnsOnCall[len(fake.upgradeDBsArgsForCall)]
	fake.upgradeDBsArgsForCall = append(fake.upgradeDBsArgsForCall, struct {
	}{})
	fake.recordInvocation("UpgradeDBs", []interface{}{})
	fake.upgradeDBsMutex.Unlock()
	if fake.UpgradeDBsStub != nil {
		return fake.UpgradeDBsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.upgradeDBsReturns
	return fakeReturns.result1
}

func (fake *Update) UpgradeDBsCallCount() int {
	fake.upgradeDBsMutex.RLock()
	defer fake.upgradeDBsMutex.RUnlock()
	return len(fake.upgradeDBsArgsForCall)
}

func (fake *Update) UpgradeDBsCalls(stub func() bool) {
	fake.upgradeDBsMutex.Lock()
	defer fake.upgradeDBsMutex.Unlock()
	fake.UpgradeDBsStub = stub
}

func (fake *Update) UpgradeDBsReturns(result1 bool) {
	fake.upgradeDBsMutex.Lock()
	defer fake.upgradeDBsMutex.Unlock()
	fake.UpgradeDBsStub = nil
	fake.upgradeDBsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Update) UpgradeDBsReturnsOnCall(i int, result1 bool) {
	fake.upgradeDBsMutex.Lock()
	defer fake.upgradeDBsMutex.Unlock()
	fake.UpgradeDBsStub = nil
	if fake.upgradeDBsReturnsOnCall == nil {
		fake.upgradeDBsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.upgradeDBsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Update) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.certificateCreatedMutex.RLock()
	defer fake.certificateCreatedMutex.RUnlock()
	fake.certificateUpdatedMutex.RLock()
	defer fake.certificateUpdatedMutex.RUnlock()
	fake.configOverridesUpdatedMutex.RLock()
	defer fake.configOverridesUpdatedMutex.RUnlock()
	fake.cryptoBackupNeededMutex.RLock()
	defer fake.cryptoBackupNeededMutex.RUnlock()
	fake.ecertEnrollMutex.RLock()
	defer fake.ecertEnrollMutex.RUnlock()
	fake.ecertNewKeyReenrollMutex.RLock()
	defer fake.ecertNewKeyReenrollMutex.RUnlock()
	fake.ecertReenrollNeededMutex.RLock()
	defer fake.ecertReenrollNeededMutex.RUnlock()
	fake.ecertUpdatedMutex.RLock()
	defer fake.ecertUpdatedMutex.RUnlock()
	fake.fabricVersionUpdatedMutex.RLock()
	defer fake.fabricVersionUpdatedMutex.RUnlock()
	fake.getCreatedCertTypeMutex.RLock()
	defer fake.getCreatedCertTypeMutex.RUnlock()
	fake.imagesUpdatedMutex.RLock()
	defer fake.imagesUpdatedMutex.RUnlock()
	fake.mSPUpdatedMutex.RLock()
	defer fake.mSPUpdatedMutex.RUnlock()
	fake.migrateToV2Mutex.RLock()
	defer fake.migrateToV2Mutex.RUnlock()
	fake.migrateToV24Mutex.RLock()
	defer fake.migrateToV24Mutex.RUnlock()
	fake.migrateToV25Mutex.RLock()
	defer fake.migrateToV25Mutex.RUnlock()
	fake.nodeOUUpdatedMutex.RLock()
	defer fake.nodeOUUpdatedMutex.RUnlock()
	fake.peerTagUpdatedMutex.RLock()
	defer fake.peerTagUpdatedMutex.RUnlock()
	fake.restartNeededMutex.RLock()
	defer fake.restartNeededMutex.RUnlock()
	fake.specUpdatedMutex.RLock()
	defer fake.specUpdatedMutex.RUnlock()
	fake.tLSCertEnrollMutex.RLock()
	defer fake.tLSCertEnrollMutex.RUnlock()
	fake.tLSCertUpdatedMutex.RLock()
	defer fake.tLSCertUpdatedMutex.RUnlock()
	fake.tLSReenrollNeededMutex.RLock()
	defer fake.tLSReenrollNeededMutex.RUnlock()
	fake.tLScertNewKeyReenrollMutex.RLock()
	defer fake.tLScertNewKeyReenrollMutex.RUnlock()
	fake.upgradeDBsMutex.RLock()
	defer fake.upgradeDBsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Update) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ basepeer.Update = new(Update)
