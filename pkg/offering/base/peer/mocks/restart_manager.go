// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/IBM-Blockchain/fabric-operator/pkg/initializer/common"
	basepeer "github.com/IBM-Blockchain/fabric-operator/pkg/offering/base/peer"
	"github.com/IBM-Blockchain/fabric-operator/pkg/restart"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type RestartManager struct {
	ForAdminCertUpdateStub        func(v1.Object) error
	forAdminCertUpdateMutex       sync.RWMutex
	forAdminCertUpdateArgsForCall []struct {
		arg1 v1.Object
	}
	forAdminCertUpdateReturns struct {
		result1 error
	}
	forAdminCertUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	ForCertUpdateStub        func(common.SecretType, v1.Object) error
	forCertUpdateMutex       sync.RWMutex
	forCertUpdateArgsForCall []struct {
		arg1 common.SecretType
		arg2 v1.Object
	}
	forCertUpdateReturns struct {
		result1 error
	}
	forCertUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	ForConfigOverrideStub        func(v1.Object) error
	forConfigOverrideMutex       sync.RWMutex
	forConfigOverrideArgsForCall []struct {
		arg1 v1.Object
	}
	forConfigOverrideReturns struct {
		result1 error
	}
	forConfigOverrideReturnsOnCall map[int]struct {
		result1 error
	}
	ForNodeOUStub        func(v1.Object) error
	forNodeOUMutex       sync.RWMutex
	forNodeOUArgsForCall []struct {
		arg1 v1.Object
	}
	forNodeOUReturns struct {
		result1 error
	}
	forNodeOUReturnsOnCall map[int]struct {
		result1 error
	}
	ForRestartActionStub        func(v1.Object) error
	forRestartActionMutex       sync.RWMutex
	forRestartActionArgsForCall []struct {
		arg1 v1.Object
	}
	forRestartActionReturns struct {
		result1 error
	}
	forRestartActionReturnsOnCall map[int]struct {
		result1 error
	}
	TriggerIfNeededStub        func(restart.Instance) error
	triggerIfNeededMutex       sync.RWMutex
	triggerIfNeededArgsForCall []struct {
		arg1 restart.Instance
	}
	triggerIfNeededReturns struct {
		result1 error
	}
	triggerIfNeededReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *RestartManager) ForAdminCertUpdate(arg1 v1.Object) error {
	fake.forAdminCertUpdateMutex.Lock()
	ret, specificReturn := fake.forAdminCertUpdateReturnsOnCall[len(fake.forAdminCertUpdateArgsForCall)]
	fake.forAdminCertUpdateArgsForCall = append(fake.forAdminCertUpdateArgsForCall, struct {
		arg1 v1.Object
	}{arg1})
	fake.recordInvocation("ForAdminCertUpdate", []interface{}{arg1})
	fake.forAdminCertUpdateMutex.Unlock()
	if fake.ForAdminCertUpdateStub != nil {
		return fake.ForAdminCertUpdateStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.forAdminCertUpdateReturns
	return fakeReturns.result1
}

func (fake *RestartManager) ForAdminCertUpdateCallCount() int {
	fake.forAdminCertUpdateMutex.RLock()
	defer fake.forAdminCertUpdateMutex.RUnlock()
	return len(fake.forAdminCertUpdateArgsForCall)
}

func (fake *RestartManager) ForAdminCertUpdateCalls(stub func(v1.Object) error) {
	fake.forAdminCertUpdateMutex.Lock()
	defer fake.forAdminCertUpdateMutex.Unlock()
	fake.ForAdminCertUpdateStub = stub
}

func (fake *RestartManager) ForAdminCertUpdateArgsForCall(i int) v1.Object {
	fake.forAdminCertUpdateMutex.RLock()
	defer fake.forAdminCertUpdateMutex.RUnlock()
	argsForCall := fake.forAdminCertUpdateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *RestartManager) ForAdminCertUpdateReturns(result1 error) {
	fake.forAdminCertUpdateMutex.Lock()
	defer fake.forAdminCertUpdateMutex.Unlock()
	fake.ForAdminCertUpdateStub = nil
	fake.forAdminCertUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *RestartManager) ForAdminCertUpdateReturnsOnCall(i int, result1 error) {
	fake.forAdminCertUpdateMutex.Lock()
	defer fake.forAdminCertUpdateMutex.Unlock()
	fake.ForAdminCertUpdateStub = nil
	if fake.forAdminCertUpdateReturnsOnCall == nil {
		fake.forAdminCertUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.forAdminCertUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RestartManager) ForCertUpdate(arg1 common.SecretType, arg2 v1.Object) error {
	fake.forCertUpdateMutex.Lock()
	ret, specificReturn := fake.forCertUpdateReturnsOnCall[len(fake.forCertUpdateArgsForCall)]
	fake.forCertUpdateArgsForCall = append(fake.forCertUpdateArgsForCall, struct {
		arg1 common.SecretType
		arg2 v1.Object
	}{arg1, arg2})
	fake.recordInvocation("ForCertUpdate", []interface{}{arg1, arg2})
	fake.forCertUpdateMutex.Unlock()
	if fake.ForCertUpdateStub != nil {
		return fake.ForCertUpdateStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.forCertUpdateReturns
	return fakeReturns.result1
}

func (fake *RestartManager) ForCertUpdateCallCount() int {
	fake.forCertUpdateMutex.RLock()
	defer fake.forCertUpdateMutex.RUnlock()
	return len(fake.forCertUpdateArgsForCall)
}

func (fake *RestartManager) ForCertUpdateCalls(stub func(common.SecretType, v1.Object) error) {
	fake.forCertUpdateMutex.Lock()
	defer fake.forCertUpdateMutex.Unlock()
	fake.ForCertUpdateStub = stub
}

func (fake *RestartManager) ForCertUpdateArgsForCall(i int) (common.SecretType, v1.Object) {
	fake.forCertUpdateMutex.RLock()
	defer fake.forCertUpdateMutex.RUnlock()
	argsForCall := fake.forCertUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *RestartManager) ForCertUpdateReturns(result1 error) {
	fake.forCertUpdateMutex.Lock()
	defer fake.forCertUpdateMutex.Unlock()
	fake.ForCertUpdateStub = nil
	fake.forCertUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *RestartManager) ForCertUpdateReturnsOnCall(i int, result1 error) {
	fake.forCertUpdateMutex.Lock()
	defer fake.forCertUpdateMutex.Unlock()
	fake.ForCertUpdateStub = nil
	if fake.forCertUpdateReturnsOnCall == nil {
		fake.forCertUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.forCertUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RestartManager) ForConfigOverride(arg1 v1.Object) error {
	fake.forConfigOverrideMutex.Lock()
	ret, specificReturn := fake.forConfigOverrideReturnsOnCall[len(fake.forConfigOverrideArgsForCall)]
	fake.forConfigOverrideArgsForCall = append(fake.forConfigOverrideArgsForCall, struct {
		arg1 v1.Object
	}{arg1})
	fake.recordInvocation("ForConfigOverride", []interface{}{arg1})
	fake.forConfigOverrideMutex.Unlock()
	if fake.ForConfigOverrideStub != nil {
		return fake.ForConfigOverrideStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.forConfigOverrideReturns
	return fakeReturns.result1
}

func (fake *RestartManager) ForConfigOverrideCallCount() int {
	fake.forConfigOverrideMutex.RLock()
	defer fake.forConfigOverrideMutex.RUnlock()
	return len(fake.forConfigOverrideArgsForCall)
}

func (fake *RestartManager) ForConfigOverrideCalls(stub func(v1.Object) error) {
	fake.forConfigOverrideMutex.Lock()
	defer fake.forConfigOverrideMutex.Unlock()
	fake.ForConfigOverrideStub = stub
}

func (fake *RestartManager) ForConfigOverrideArgsForCall(i int) v1.Object {
	fake.forConfigOverrideMutex.RLock()
	defer fake.forConfigOverrideMutex.RUnlock()
	argsForCall := fake.forConfigOverrideArgsForCall[i]
	return argsForCall.arg1
}

func (fake *RestartManager) ForConfigOverrideReturns(result1 error) {
	fake.forConfigOverrideMutex.Lock()
	defer fake.forConfigOverrideMutex.Unlock()
	fake.ForConfigOverrideStub = nil
	fake.forConfigOverrideReturns = struct {
		result1 error
	}{result1}
}

func (fake *RestartManager) ForConfigOverrideReturnsOnCall(i int, result1 error) {
	fake.forConfigOverrideMutex.Lock()
	defer fake.forConfigOverrideMutex.Unlock()
	fake.ForConfigOverrideStub = nil
	if fake.forConfigOverrideReturnsOnCall == nil {
		fake.forConfigOverrideReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.forConfigOverrideReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RestartManager) ForNodeOU(arg1 v1.Object) error {
	fake.forNodeOUMutex.Lock()
	ret, specificReturn := fake.forNodeOUReturnsOnCall[len(fake.forNodeOUArgsForCall)]
	fake.forNodeOUArgsForCall = append(fake.forNodeOUArgsForCall, struct {
		arg1 v1.Object
	}{arg1})
	fake.recordInvocation("ForNodeOU", []interface{}{arg1})
	fake.forNodeOUMutex.Unlock()
	if fake.ForNodeOUStub != nil {
		return fake.ForNodeOUStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.forNodeOUReturns
	return fakeReturns.result1
}

func (fake *RestartManager) ForNodeOUCallCount() int {
	fake.forNodeOUMutex.RLock()
	defer fake.forNodeOUMutex.RUnlock()
	return len(fake.forNodeOUArgsForCall)
}

func (fake *RestartManager) ForNodeOUCalls(stub func(v1.Object) error) {
	fake.forNodeOUMutex.Lock()
	defer fake.forNodeOUMutex.Unlock()
	fake.ForNodeOUStub = stub
}

func (fake *RestartManager) ForNodeOUArgsForCall(i int) v1.Object {
	fake.forNodeOUMutex.RLock()
	defer fake.forNodeOUMutex.RUnlock()
	argsForCall := fake.forNodeOUArgsForCall[i]
	return argsForCall.arg1
}

func (fake *RestartManager) ForNodeOUReturns(result1 error) {
	fake.forNodeOUMutex.Lock()
	defer fake.forNodeOUMutex.Unlock()
	fake.ForNodeOUStub = nil
	fake.forNodeOUReturns = struct {
		result1 error
	}{result1}
}

func (fake *RestartManager) ForNodeOUReturnsOnCall(i int, result1 error) {
	fake.forNodeOUMutex.Lock()
	defer fake.forNodeOUMutex.Unlock()
	fake.ForNodeOUStub = nil
	if fake.forNodeOUReturnsOnCall == nil {
		fake.forNodeOUReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.forNodeOUReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RestartManager) ForRestartAction(arg1 v1.Object) error {
	fake.forRestartActionMutex.Lock()
	ret, specificReturn := fake.forRestartActionReturnsOnCall[len(fake.forRestartActionArgsForCall)]
	fake.forRestartActionArgsForCall = append(fake.forRestartActionArgsForCall, struct {
		arg1 v1.Object
	}{arg1})
	fake.recordInvocation("ForRestartAction", []interface{}{arg1})
	fake.forRestartActionMutex.Unlock()
	if fake.ForRestartActionStub != nil {
		return fake.ForRestartActionStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.forRestartActionReturns
	return fakeReturns.result1
}

func (fake *RestartManager) ForRestartActionCallCount() int {
	fake.forRestartActionMutex.RLock()
	defer fake.forRestartActionMutex.RUnlock()
	return len(fake.forRestartActionArgsForCall)
}

func (fake *RestartManager) ForRestartActionCalls(stub func(v1.Object) error) {
	fake.forRestartActionMutex.Lock()
	defer fake.forRestartActionMutex.Unlock()
	fake.ForRestartActionStub = stub
}

func (fake *RestartManager) ForRestartActionArgsForCall(i int) v1.Object {
	fake.forRestartActionMutex.RLock()
	defer fake.forRestartActionMutex.RUnlock()
	argsForCall := fake.forRestartActionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *RestartManager) ForRestartActionReturns(result1 error) {
	fake.forRestartActionMutex.Lock()
	defer fake.forRestartActionMutex.Unlock()
	fake.ForRestartActionStub = nil
	fake.forRestartActionReturns = struct {
		result1 error
	}{result1}
}

func (fake *RestartManager) ForRestartActionReturnsOnCall(i int, result1 error) {
	fake.forRestartActionMutex.Lock()
	defer fake.forRestartActionMutex.Unlock()
	fake.ForRestartActionStub = nil
	if fake.forRestartActionReturnsOnCall == nil {
		fake.forRestartActionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.forRestartActionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RestartManager) TriggerIfNeeded(arg1 restart.Instance) error {
	fake.triggerIfNeededMutex.Lock()
	ret, specificReturn := fake.triggerIfNeededReturnsOnCall[len(fake.triggerIfNeededArgsForCall)]
	fake.triggerIfNeededArgsForCall = append(fake.triggerIfNeededArgsForCall, struct {
		arg1 restart.Instance
	}{arg1})
	fake.recordInvocation("TriggerIfNeeded", []interface{}{arg1})
	fake.triggerIfNeededMutex.Unlock()
	if fake.TriggerIfNeededStub != nil {
		return fake.TriggerIfNeededStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.triggerIfNeededReturns
	return fakeReturns.result1
}

func (fake *RestartManager) TriggerIfNeededCallCount() int {
	fake.triggerIfNeededMutex.RLock()
	defer fake.triggerIfNeededMutex.RUnlock()
	return len(fake.triggerIfNeededArgsForCall)
}

func (fake *RestartManager) TriggerIfNeededCalls(stub func(restart.Instance) error) {
	fake.triggerIfNeededMutex.Lock()
	defer fake.triggerIfNeededMutex.Unlock()
	fake.TriggerIfNeededStub = stub
}

func (fake *RestartManager) TriggerIfNeededArgsForCall(i int) restart.Instance {
	fake.triggerIfNeededMutex.RLock()
	defer fake.triggerIfNeededMutex.RUnlock()
	argsForCall := fake.triggerIfNeededArgsForCall[i]
	return argsForCall.arg1
}

func (fake *RestartManager) TriggerIfNeededReturns(result1 error) {
	fake.triggerIfNeededMutex.Lock()
	defer fake.triggerIfNeededMutex.Unlock()
	fake.TriggerIfNeededStub = nil
	fake.triggerIfNeededReturns = struct {
		result1 error
	}{result1}
}

func (fake *RestartManager) TriggerIfNeededReturnsOnCall(i int, result1 error) {
	fake.triggerIfNeededMutex.Lock()
	defer fake.triggerIfNeededMutex.Unlock()
	fake.TriggerIfNeededStub = nil
	if fake.triggerIfNeededReturnsOnCall == nil {
		fake.triggerIfNeededReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.triggerIfNeededReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RestartManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.forAdminCertUpdateMutex.RLock()
	defer fake.forAdminCertUpdateMutex.RUnlock()
	fake.forCertUpdateMutex.RLock()
	defer fake.forCertUpdateMutex.RUnlock()
	fake.forConfigOverrideMutex.RLock()
	defer fake.forConfigOverrideMutex.RUnlock()
	fake.forNodeOUMutex.RLock()
	defer fake.forNodeOUMutex.RUnlock()
	fake.forRestartActionMutex.RLock()
	defer fake.forRestartActionMutex.RUnlock()
	fake.triggerIfNeededMutex.RLock()
	defer fake.triggerIfNeededMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *RestartManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ basepeer.RestartManager = new(RestartManager)
