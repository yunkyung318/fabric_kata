// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	v1 "github.com/IBM-Blockchain/fabric-operator/pkg/apis/ca/v1"
	initializer "github.com/IBM-Blockchain/fabric-operator/pkg/initializer/ca"
	"github.com/IBM-Blockchain/fabric-operator/pkg/initializer/ca/config"
	"github.com/hyperledger/fabric-ca/lib"
)

type IBPCA struct {
	ConfigToBytesStub        func() ([]byte, error)
	configToBytesMutex       sync.RWMutex
	configToBytesArgsForCall []struct {
	}
	configToBytesReturns struct {
		result1 []byte
		result2 error
	}
	configToBytesReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetHomeDirStub        func() string
	getHomeDirMutex       sync.RWMutex
	getHomeDirArgsForCall []struct {
	}
	getHomeDirReturns struct {
		result1 string
	}
	getHomeDirReturnsOnCall map[int]struct {
		result1 string
	}
	GetServerConfigStub        func() *v1.ServerConfig
	getServerConfigMutex       sync.RWMutex
	getServerConfigArgsForCall []struct {
	}
	getServerConfigReturns struct {
		result1 *v1.ServerConfig
	}
	getServerConfigReturnsOnCall map[int]struct {
		result1 *v1.ServerConfig
	}
	GetTypeStub        func() config.Type
	getTypeMutex       sync.RWMutex
	getTypeArgsForCall []struct {
	}
	getTypeReturns struct {
		result1 config.Type
	}
	getTypeReturnsOnCall map[int]struct {
		result1 config.Type
	}
	InitStub        func() error
	initMutex       sync.RWMutex
	initArgsForCall []struct {
	}
	initReturns struct {
		result1 error
	}
	initReturnsOnCall map[int]struct {
		result1 error
	}
	IsBeingUpdatedStub        func()
	isBeingUpdatedMutex       sync.RWMutex
	isBeingUpdatedArgsForCall []struct {
	}
	OverrideServerConfigStub        func(*v1.ServerConfig) error
	overrideServerConfigMutex       sync.RWMutex
	overrideServerConfigArgsForCall []struct {
		arg1 *v1.ServerConfig
	}
	overrideServerConfigReturns struct {
		result1 error
	}
	overrideServerConfigReturnsOnCall map[int]struct {
		result1 error
	}
	ParseCABlockStub        func() (map[string][]byte, error)
	parseCABlockMutex       sync.RWMutex
	parseCABlockArgsForCall []struct {
	}
	parseCABlockReturns struct {
		result1 map[string][]byte
		result2 error
	}
	parseCABlockReturnsOnCall map[int]struct {
		result1 map[string][]byte
		result2 error
	}
	ParseCryptoStub        func() (map[string][]byte, error)
	parseCryptoMutex       sync.RWMutex
	parseCryptoArgsForCall []struct {
	}
	parseCryptoReturns struct {
		result1 map[string][]byte
		result2 error
	}
	parseCryptoReturnsOnCall map[int]struct {
		result1 map[string][]byte
		result2 error
	}
	RemoveHomeDirStub        func() error
	removeHomeDirMutex       sync.RWMutex
	removeHomeDirArgsForCall []struct {
	}
	removeHomeDirReturns struct {
		result1 error
	}
	removeHomeDirReturnsOnCall map[int]struct {
		result1 error
	}
	SetMountPathsStub        func()
	setMountPathsMutex       sync.RWMutex
	setMountPathsArgsForCall []struct {
	}
	ViperUnmarshalStub        func(string) (*lib.ServerConfig, error)
	viperUnmarshalMutex       sync.RWMutex
	viperUnmarshalArgsForCall []struct {
		arg1 string
	}
	viperUnmarshalReturns struct {
		result1 *lib.ServerConfig
		result2 error
	}
	viperUnmarshalReturnsOnCall map[int]struct {
		result1 *lib.ServerConfig
		result2 error
	}
	WriteConfigStub        func() error
	writeConfigMutex       sync.RWMutex
	writeConfigArgsForCall []struct {
	}
	writeConfigReturns struct {
		result1 error
	}
	writeConfigReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *IBPCA) ConfigToBytes() ([]byte, error) {
	fake.configToBytesMutex.Lock()
	ret, specificReturn := fake.configToBytesReturnsOnCall[len(fake.configToBytesArgsForCall)]
	fake.configToBytesArgsForCall = append(fake.configToBytesArgsForCall, struct {
	}{})
	fake.recordInvocation("ConfigToBytes", []interface{}{})
	fake.configToBytesMutex.Unlock()
	if fake.ConfigToBytesStub != nil {
		return fake.ConfigToBytesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.configToBytesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *IBPCA) ConfigToBytesCallCount() int {
	fake.configToBytesMutex.RLock()
	defer fake.configToBytesMutex.RUnlock()
	return len(fake.configToBytesArgsForCall)
}

func (fake *IBPCA) ConfigToBytesCalls(stub func() ([]byte, error)) {
	fake.configToBytesMutex.Lock()
	defer fake.configToBytesMutex.Unlock()
	fake.ConfigToBytesStub = stub
}

func (fake *IBPCA) ConfigToBytesReturns(result1 []byte, result2 error) {
	fake.configToBytesMutex.Lock()
	defer fake.configToBytesMutex.Unlock()
	fake.ConfigToBytesStub = nil
	fake.configToBytesReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *IBPCA) ConfigToBytesReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.configToBytesMutex.Lock()
	defer fake.configToBytesMutex.Unlock()
	fake.ConfigToBytesStub = nil
	if fake.configToBytesReturnsOnCall == nil {
		fake.configToBytesReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.configToBytesReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *IBPCA) GetHomeDir() string {
	fake.getHomeDirMutex.Lock()
	ret, specificReturn := fake.getHomeDirReturnsOnCall[len(fake.getHomeDirArgsForCall)]
	fake.getHomeDirArgsForCall = append(fake.getHomeDirArgsForCall, struct {
	}{})
	fake.recordInvocation("GetHomeDir", []interface{}{})
	fake.getHomeDirMutex.Unlock()
	if fake.GetHomeDirStub != nil {
		return fake.GetHomeDirStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getHomeDirReturns
	return fakeReturns.result1
}

func (fake *IBPCA) GetHomeDirCallCount() int {
	fake.getHomeDirMutex.RLock()
	defer fake.getHomeDirMutex.RUnlock()
	return len(fake.getHomeDirArgsForCall)
}

func (fake *IBPCA) GetHomeDirCalls(stub func() string) {
	fake.getHomeDirMutex.Lock()
	defer fake.getHomeDirMutex.Unlock()
	fake.GetHomeDirStub = stub
}

func (fake *IBPCA) GetHomeDirReturns(result1 string) {
	fake.getHomeDirMutex.Lock()
	defer fake.getHomeDirMutex.Unlock()
	fake.GetHomeDirStub = nil
	fake.getHomeDirReturns = struct {
		result1 string
	}{result1}
}

func (fake *IBPCA) GetHomeDirReturnsOnCall(i int, result1 string) {
	fake.getHomeDirMutex.Lock()
	defer fake.getHomeDirMutex.Unlock()
	fake.GetHomeDirStub = nil
	if fake.getHomeDirReturnsOnCall == nil {
		fake.getHomeDirReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getHomeDirReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *IBPCA) GetServerConfig() *v1.ServerConfig {
	fake.getServerConfigMutex.Lock()
	ret, specificReturn := fake.getServerConfigReturnsOnCall[len(fake.getServerConfigArgsForCall)]
	fake.getServerConfigArgsForCall = append(fake.getServerConfigArgsForCall, struct {
	}{})
	fake.recordInvocation("GetServerConfig", []interface{}{})
	fake.getServerConfigMutex.Unlock()
	if fake.GetServerConfigStub != nil {
		return fake.GetServerConfigStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getServerConfigReturns
	return fakeReturns.result1
}

func (fake *IBPCA) GetServerConfigCallCount() int {
	fake.getServerConfigMutex.RLock()
	defer fake.getServerConfigMutex.RUnlock()
	return len(fake.getServerConfigArgsForCall)
}

func (fake *IBPCA) GetServerConfigCalls(stub func() *v1.ServerConfig) {
	fake.getServerConfigMutex.Lock()
	defer fake.getServerConfigMutex.Unlock()
	fake.GetServerConfigStub = stub
}

func (fake *IBPCA) GetServerConfigReturns(result1 *v1.ServerConfig) {
	fake.getServerConfigMutex.Lock()
	defer fake.getServerConfigMutex.Unlock()
	fake.GetServerConfigStub = nil
	fake.getServerConfigReturns = struct {
		result1 *v1.ServerConfig
	}{result1}
}

func (fake *IBPCA) GetServerConfigReturnsOnCall(i int, result1 *v1.ServerConfig) {
	fake.getServerConfigMutex.Lock()
	defer fake.getServerConfigMutex.Unlock()
	fake.GetServerConfigStub = nil
	if fake.getServerConfigReturnsOnCall == nil {
		fake.getServerConfigReturnsOnCall = make(map[int]struct {
			result1 *v1.ServerConfig
		})
	}
	fake.getServerConfigReturnsOnCall[i] = struct {
		result1 *v1.ServerConfig
	}{result1}
}

func (fake *IBPCA) GetType() config.Type {
	fake.getTypeMutex.Lock()
	ret, specificReturn := fake.getTypeReturnsOnCall[len(fake.getTypeArgsForCall)]
	fake.getTypeArgsForCall = append(fake.getTypeArgsForCall, struct {
	}{})
	fake.recordInvocation("GetType", []interface{}{})
	fake.getTypeMutex.Unlock()
	if fake.GetTypeStub != nil {
		return fake.GetTypeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getTypeReturns
	return fakeReturns.result1
}

func (fake *IBPCA) GetTypeCallCount() int {
	fake.getTypeMutex.RLock()
	defer fake.getTypeMutex.RUnlock()
	return len(fake.getTypeArgsForCall)
}

func (fake *IBPCA) GetTypeCalls(stub func() config.Type) {
	fake.getTypeMutex.Lock()
	defer fake.getTypeMutex.Unlock()
	fake.GetTypeStub = stub
}

func (fake *IBPCA) GetTypeReturns(result1 config.Type) {
	fake.getTypeMutex.Lock()
	defer fake.getTypeMutex.Unlock()
	fake.GetTypeStub = nil
	fake.getTypeReturns = struct {
		result1 config.Type
	}{result1}
}

func (fake *IBPCA) GetTypeReturnsOnCall(i int, result1 config.Type) {
	fake.getTypeMutex.Lock()
	defer fake.getTypeMutex.Unlock()
	fake.GetTypeStub = nil
	if fake.getTypeReturnsOnCall == nil {
		fake.getTypeReturnsOnCall = make(map[int]struct {
			result1 config.Type
		})
	}
	fake.getTypeReturnsOnCall[i] = struct {
		result1 config.Type
	}{result1}
}

func (fake *IBPCA) Init() error {
	fake.initMutex.Lock()
	ret, specificReturn := fake.initReturnsOnCall[len(fake.initArgsForCall)]
	fake.initArgsForCall = append(fake.initArgsForCall, struct {
	}{})
	fake.recordInvocation("Init", []interface{}{})
	fake.initMutex.Unlock()
	if fake.InitStub != nil {
		return fake.InitStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.initReturns
	return fakeReturns.result1
}

func (fake *IBPCA) InitCallCount() int {
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	return len(fake.initArgsForCall)
}

func (fake *IBPCA) InitCalls(stub func() error) {
	fake.initMutex.Lock()
	defer fake.initMutex.Unlock()
	fake.InitStub = stub
}

func (fake *IBPCA) InitReturns(result1 error) {
	fake.initMutex.Lock()
	defer fake.initMutex.Unlock()
	fake.InitStub = nil
	fake.initReturns = struct {
		result1 error
	}{result1}
}

func (fake *IBPCA) InitReturnsOnCall(i int, result1 error) {
	fake.initMutex.Lock()
	defer fake.initMutex.Unlock()
	fake.InitStub = nil
	if fake.initReturnsOnCall == nil {
		fake.initReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *IBPCA) IsBeingUpdated() {
	fake.isBeingUpdatedMutex.Lock()
	fake.isBeingUpdatedArgsForCall = append(fake.isBeingUpdatedArgsForCall, struct {
	}{})
	fake.recordInvocation("IsBeingUpdated", []interface{}{})
	fake.isBeingUpdatedMutex.Unlock()
	if fake.IsBeingUpdatedStub != nil {
		fake.IsBeingUpdatedStub()
	}
}

func (fake *IBPCA) IsBeingUpdatedCallCount() int {
	fake.isBeingUpdatedMutex.RLock()
	defer fake.isBeingUpdatedMutex.RUnlock()
	return len(fake.isBeingUpdatedArgsForCall)
}

func (fake *IBPCA) IsBeingUpdatedCalls(stub func()) {
	fake.isBeingUpdatedMutex.Lock()
	defer fake.isBeingUpdatedMutex.Unlock()
	fake.IsBeingUpdatedStub = stub
}

func (fake *IBPCA) OverrideServerConfig(arg1 *v1.ServerConfig) error {
	fake.overrideServerConfigMutex.Lock()
	ret, specificReturn := fake.overrideServerConfigReturnsOnCall[len(fake.overrideServerConfigArgsForCall)]
	fake.overrideServerConfigArgsForCall = append(fake.overrideServerConfigArgsForCall, struct {
		arg1 *v1.ServerConfig
	}{arg1})
	fake.recordInvocation("OverrideServerConfig", []interface{}{arg1})
	fake.overrideServerConfigMutex.Unlock()
	if fake.OverrideServerConfigStub != nil {
		return fake.OverrideServerConfigStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.overrideServerConfigReturns
	return fakeReturns.result1
}

func (fake *IBPCA) OverrideServerConfigCallCount() int {
	fake.overrideServerConfigMutex.RLock()
	defer fake.overrideServerConfigMutex.RUnlock()
	return len(fake.overrideServerConfigArgsForCall)
}

func (fake *IBPCA) OverrideServerConfigCalls(stub func(*v1.ServerConfig) error) {
	fake.overrideServerConfigMutex.Lock()
	defer fake.overrideServerConfigMutex.Unlock()
	fake.OverrideServerConfigStub = stub
}

func (fake *IBPCA) OverrideServerConfigArgsForCall(i int) *v1.ServerConfig {
	fake.overrideServerConfigMutex.RLock()
	defer fake.overrideServerConfigMutex.RUnlock()
	argsForCall := fake.overrideServerConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *IBPCA) OverrideServerConfigReturns(result1 error) {
	fake.overrideServerConfigMutex.Lock()
	defer fake.overrideServerConfigMutex.Unlock()
	fake.OverrideServerConfigStub = nil
	fake.overrideServerConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *IBPCA) OverrideServerConfigReturnsOnCall(i int, result1 error) {
	fake.overrideServerConfigMutex.Lock()
	defer fake.overrideServerConfigMutex.Unlock()
	fake.OverrideServerConfigStub = nil
	if fake.overrideServerConfigReturnsOnCall == nil {
		fake.overrideServerConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.overrideServerConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *IBPCA) ParseCABlock() (map[string][]byte, error) {
	fake.parseCABlockMutex.Lock()
	ret, specificReturn := fake.parseCABlockReturnsOnCall[len(fake.parseCABlockArgsForCall)]
	fake.parseCABlockArgsForCall = append(fake.parseCABlockArgsForCall, struct {
	}{})
	fake.recordInvocation("ParseCABlock", []interface{}{})
	fake.parseCABlockMutex.Unlock()
	if fake.ParseCABlockStub != nil {
		return fake.ParseCABlockStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.parseCABlockReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *IBPCA) ParseCABlockCallCount() int {
	fake.parseCABlockMutex.RLock()
	defer fake.parseCABlockMutex.RUnlock()
	return len(fake.parseCABlockArgsForCall)
}

func (fake *IBPCA) ParseCABlockCalls(stub func() (map[string][]byte, error)) {
	fake.parseCABlockMutex.Lock()
	defer fake.parseCABlockMutex.Unlock()
	fake.ParseCABlockStub = stub
}

func (fake *IBPCA) ParseCABlockReturns(result1 map[string][]byte, result2 error) {
	fake.parseCABlockMutex.Lock()
	defer fake.parseCABlockMutex.Unlock()
	fake.ParseCABlockStub = nil
	fake.parseCABlockReturns = struct {
		result1 map[string][]byte
		result2 error
	}{result1, result2}
}

func (fake *IBPCA) ParseCABlockReturnsOnCall(i int, result1 map[string][]byte, result2 error) {
	fake.parseCABlockMutex.Lock()
	defer fake.parseCABlockMutex.Unlock()
	fake.ParseCABlockStub = nil
	if fake.parseCABlockReturnsOnCall == nil {
		fake.parseCABlockReturnsOnCall = make(map[int]struct {
			result1 map[string][]byte
			result2 error
		})
	}
	fake.parseCABlockReturnsOnCall[i] = struct {
		result1 map[string][]byte
		result2 error
	}{result1, result2}
}

func (fake *IBPCA) ParseCrypto() (map[string][]byte, error) {
	fake.parseCryptoMutex.Lock()
	ret, specificReturn := fake.parseCryptoReturnsOnCall[len(fake.parseCryptoArgsForCall)]
	fake.parseCryptoArgsForCall = append(fake.parseCryptoArgsForCall, struct {
	}{})
	fake.recordInvocation("ParseCrypto", []interface{}{})
	fake.parseCryptoMutex.Unlock()
	if fake.ParseCryptoStub != nil {
		return fake.ParseCryptoStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.parseCryptoReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *IBPCA) ParseCryptoCallCount() int {
	fake.parseCryptoMutex.RLock()
	defer fake.parseCryptoMutex.RUnlock()
	return len(fake.parseCryptoArgsForCall)
}

func (fake *IBPCA) ParseCryptoCalls(stub func() (map[string][]byte, error)) {
	fake.parseCryptoMutex.Lock()
	defer fake.parseCryptoMutex.Unlock()
	fake.ParseCryptoStub = stub
}

func (fake *IBPCA) ParseCryptoReturns(result1 map[string][]byte, result2 error) {
	fake.parseCryptoMutex.Lock()
	defer fake.parseCryptoMutex.Unlock()
	fake.ParseCryptoStub = nil
	fake.parseCryptoReturns = struct {
		result1 map[string][]byte
		result2 error
	}{result1, result2}
}

func (fake *IBPCA) ParseCryptoReturnsOnCall(i int, result1 map[string][]byte, result2 error) {
	fake.parseCryptoMutex.Lock()
	defer fake.parseCryptoMutex.Unlock()
	fake.ParseCryptoStub = nil
	if fake.parseCryptoReturnsOnCall == nil {
		fake.parseCryptoReturnsOnCall = make(map[int]struct {
			result1 map[string][]byte
			result2 error
		})
	}
	fake.parseCryptoReturnsOnCall[i] = struct {
		result1 map[string][]byte
		result2 error
	}{result1, result2}
}

func (fake *IBPCA) RemoveHomeDir() error {
	fake.removeHomeDirMutex.Lock()
	ret, specificReturn := fake.removeHomeDirReturnsOnCall[len(fake.removeHomeDirArgsForCall)]
	fake.removeHomeDirArgsForCall = append(fake.removeHomeDirArgsForCall, struct {
	}{})
	fake.recordInvocation("RemoveHomeDir", []interface{}{})
	fake.removeHomeDirMutex.Unlock()
	if fake.RemoveHomeDirStub != nil {
		return fake.RemoveHomeDirStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeHomeDirReturns
	return fakeReturns.result1
}

func (fake *IBPCA) RemoveHomeDirCallCount() int {
	fake.removeHomeDirMutex.RLock()
	defer fake.removeHomeDirMutex.RUnlock()
	return len(fake.removeHomeDirArgsForCall)
}

func (fake *IBPCA) RemoveHomeDirCalls(stub func() error) {
	fake.removeHomeDirMutex.Lock()
	defer fake.removeHomeDirMutex.Unlock()
	fake.RemoveHomeDirStub = stub
}

func (fake *IBPCA) RemoveHomeDirReturns(result1 error) {
	fake.removeHomeDirMutex.Lock()
	defer fake.removeHomeDirMutex.Unlock()
	fake.RemoveHomeDirStub = nil
	fake.removeHomeDirReturns = struct {
		result1 error
	}{result1}
}

func (fake *IBPCA) RemoveHomeDirReturnsOnCall(i int, result1 error) {
	fake.removeHomeDirMutex.Lock()
	defer fake.removeHomeDirMutex.Unlock()
	fake.RemoveHomeDirStub = nil
	if fake.removeHomeDirReturnsOnCall == nil {
		fake.removeHomeDirReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeHomeDirReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *IBPCA) SetMountPaths() {
	fake.setMountPathsMutex.Lock()
	fake.setMountPathsArgsForCall = append(fake.setMountPathsArgsForCall, struct {
	}{})
	fake.recordInvocation("SetMountPaths", []interface{}{})
	fake.setMountPathsMutex.Unlock()
	if fake.SetMountPathsStub != nil {
		fake.SetMountPathsStub()
	}
}

func (fake *IBPCA) SetMountPathsCallCount() int {
	fake.setMountPathsMutex.RLock()
	defer fake.setMountPathsMutex.RUnlock()
	return len(fake.setMountPathsArgsForCall)
}

func (fake *IBPCA) SetMountPathsCalls(stub func()) {
	fake.setMountPathsMutex.Lock()
	defer fake.setMountPathsMutex.Unlock()
	fake.SetMountPathsStub = stub
}

func (fake *IBPCA) ViperUnmarshal(arg1 string) (*lib.ServerConfig, error) {
	fake.viperUnmarshalMutex.Lock()
	ret, specificReturn := fake.viperUnmarshalReturnsOnCall[len(fake.viperUnmarshalArgsForCall)]
	fake.viperUnmarshalArgsForCall = append(fake.viperUnmarshalArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ViperUnmarshal", []interface{}{arg1})
	fake.viperUnmarshalMutex.Unlock()
	if fake.ViperUnmarshalStub != nil {
		return fake.ViperUnmarshalStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.viperUnmarshalReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *IBPCA) ViperUnmarshalCallCount() int {
	fake.viperUnmarshalMutex.RLock()
	defer fake.viperUnmarshalMutex.RUnlock()
	return len(fake.viperUnmarshalArgsForCall)
}

func (fake *IBPCA) ViperUnmarshalCalls(stub func(string) (*lib.ServerConfig, error)) {
	fake.viperUnmarshalMutex.Lock()
	defer fake.viperUnmarshalMutex.Unlock()
	fake.ViperUnmarshalStub = stub
}

func (fake *IBPCA) ViperUnmarshalArgsForCall(i int) string {
	fake.viperUnmarshalMutex.RLock()
	defer fake.viperUnmarshalMutex.RUnlock()
	argsForCall := fake.viperUnmarshalArgsForCall[i]
	return argsForCall.arg1
}

func (fake *IBPCA) ViperUnmarshalReturns(result1 *lib.ServerConfig, result2 error) {
	fake.viperUnmarshalMutex.Lock()
	defer fake.viperUnmarshalMutex.Unlock()
	fake.ViperUnmarshalStub = nil
	fake.viperUnmarshalReturns = struct {
		result1 *lib.ServerConfig
		result2 error
	}{result1, result2}
}

func (fake *IBPCA) ViperUnmarshalReturnsOnCall(i int, result1 *lib.ServerConfig, result2 error) {
	fake.viperUnmarshalMutex.Lock()
	defer fake.viperUnmarshalMutex.Unlock()
	fake.ViperUnmarshalStub = nil
	if fake.viperUnmarshalReturnsOnCall == nil {
		fake.viperUnmarshalReturnsOnCall = make(map[int]struct {
			result1 *lib.ServerConfig
			result2 error
		})
	}
	fake.viperUnmarshalReturnsOnCall[i] = struct {
		result1 *lib.ServerConfig
		result2 error
	}{result1, result2}
}

func (fake *IBPCA) WriteConfig() error {
	fake.writeConfigMutex.Lock()
	ret, specificReturn := fake.writeConfigReturnsOnCall[len(fake.writeConfigArgsForCall)]
	fake.writeConfigArgsForCall = append(fake.writeConfigArgsForCall, struct {
	}{})
	fake.recordInvocation("WriteConfig", []interface{}{})
	fake.writeConfigMutex.Unlock()
	if fake.WriteConfigStub != nil {
		return fake.WriteConfigStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.writeConfigReturns
	return fakeReturns.result1
}

func (fake *IBPCA) WriteConfigCallCount() int {
	fake.writeConfigMutex.RLock()
	defer fake.writeConfigMutex.RUnlock()
	return len(fake.writeConfigArgsForCall)
}

func (fake *IBPCA) WriteConfigCalls(stub func() error) {
	fake.writeConfigMutex.Lock()
	defer fake.writeConfigMutex.Unlock()
	fake.WriteConfigStub = stub
}

func (fake *IBPCA) WriteConfigReturns(result1 error) {
	fake.writeConfigMutex.Lock()
	defer fake.writeConfigMutex.Unlock()
	fake.WriteConfigStub = nil
	fake.writeConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *IBPCA) WriteConfigReturnsOnCall(i int, result1 error) {
	fake.writeConfigMutex.Lock()
	defer fake.writeConfigMutex.Unlock()
	fake.WriteConfigStub = nil
	if fake.writeConfigReturnsOnCall == nil {
		fake.writeConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writeConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *IBPCA) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.configToBytesMutex.RLock()
	defer fake.configToBytesMutex.RUnlock()
	fake.getHomeDirMutex.RLock()
	defer fake.getHomeDirMutex.RUnlock()
	fake.getServerConfigMutex.RLock()
	defer fake.getServerConfigMutex.RUnlock()
	fake.getTypeMutex.RLock()
	defer fake.getTypeMutex.RUnlock()
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	fake.isBeingUpdatedMutex.RLock()
	defer fake.isBeingUpdatedMutex.RUnlock()
	fake.overrideServerConfigMutex.RLock()
	defer fake.overrideServerConfigMutex.RUnlock()
	fake.parseCABlockMutex.RLock()
	defer fake.parseCABlockMutex.RUnlock()
	fake.parseCryptoMutex.RLock()
	defer fake.parseCryptoMutex.RUnlock()
	fake.removeHomeDirMutex.RLock()
	defer fake.removeHomeDirMutex.RUnlock()
	fake.setMountPathsMutex.RLock()
	defer fake.setMountPathsMutex.RUnlock()
	fake.viperUnmarshalMutex.RLock()
	defer fake.viperUnmarshalMutex.RUnlock()
	fake.writeConfigMutex.RLock()
	defer fake.writeConfigMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *IBPCA) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ initializer.IBPCA = new(IBPCA)
