// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/IBM-Blockchain/fabric-operator/operatorconfig"
	"github.com/IBM-Blockchain/fabric-operator/pkg/migrator/peer/fabric"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type Migrator struct {
	MigrationNeededStub        func(v1.Object) bool
	migrationNeededMutex       sync.RWMutex
	migrationNeededArgsForCall []struct {
		arg1 v1.Object
	}
	migrationNeededReturns struct {
		result1 bool
	}
	migrationNeededReturnsOnCall map[int]struct {
		result1 bool
	}
	SetChaincodeLauncherResourceOnCRStub        func(v1.Object) error
	setChaincodeLauncherResourceOnCRMutex       sync.RWMutex
	setChaincodeLauncherResourceOnCRArgsForCall []struct {
		arg1 v1.Object
	}
	setChaincodeLauncherResourceOnCRReturns struct {
		result1 error
	}
	setChaincodeLauncherResourceOnCRReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateConfigStub        func(v1.Object, string) error
	updateConfigMutex       sync.RWMutex
	updateConfigArgsForCall []struct {
		arg1 v1.Object
		arg2 string
	}
	updateConfigReturns struct {
		result1 error
	}
	updateConfigReturnsOnCall map[int]struct {
		result1 error
	}
	UpgradeDBsStub        func(v1.Object, operatorconfig.DBMigrationTimeouts) error
	upgradeDBsMutex       sync.RWMutex
	upgradeDBsArgsForCall []struct {
		arg1 v1.Object
		arg2 operatorconfig.DBMigrationTimeouts
	}
	upgradeDBsReturns struct {
		result1 error
	}
	upgradeDBsReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Migrator) MigrationNeeded(arg1 v1.Object) bool {
	fake.migrationNeededMutex.Lock()
	ret, specificReturn := fake.migrationNeededReturnsOnCall[len(fake.migrationNeededArgsForCall)]
	fake.migrationNeededArgsForCall = append(fake.migrationNeededArgsForCall, struct {
		arg1 v1.Object
	}{arg1})
	fake.recordInvocation("MigrationNeeded", []interface{}{arg1})
	fake.migrationNeededMutex.Unlock()
	if fake.MigrationNeededStub != nil {
		return fake.MigrationNeededStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.migrationNeededReturns
	return fakeReturns.result1
}

func (fake *Migrator) MigrationNeededCallCount() int {
	fake.migrationNeededMutex.RLock()
	defer fake.migrationNeededMutex.RUnlock()
	return len(fake.migrationNeededArgsForCall)
}

func (fake *Migrator) MigrationNeededCalls(stub func(v1.Object) bool) {
	fake.migrationNeededMutex.Lock()
	defer fake.migrationNeededMutex.Unlock()
	fake.MigrationNeededStub = stub
}

func (fake *Migrator) MigrationNeededArgsForCall(i int) v1.Object {
	fake.migrationNeededMutex.RLock()
	defer fake.migrationNeededMutex.RUnlock()
	argsForCall := fake.migrationNeededArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Migrator) MigrationNeededReturns(result1 bool) {
	fake.migrationNeededMutex.Lock()
	defer fake.migrationNeededMutex.Unlock()
	fake.MigrationNeededStub = nil
	fake.migrationNeededReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Migrator) MigrationNeededReturnsOnCall(i int, result1 bool) {
	fake.migrationNeededMutex.Lock()
	defer fake.migrationNeededMutex.Unlock()
	fake.MigrationNeededStub = nil
	if fake.migrationNeededReturnsOnCall == nil {
		fake.migrationNeededReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.migrationNeededReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Migrator) SetChaincodeLauncherResourceOnCR(arg1 v1.Object) error {
	fake.setChaincodeLauncherResourceOnCRMutex.Lock()
	ret, specificReturn := fake.setChaincodeLauncherResourceOnCRReturnsOnCall[len(fake.setChaincodeLauncherResourceOnCRArgsForCall)]
	fake.setChaincodeLauncherResourceOnCRArgsForCall = append(fake.setChaincodeLauncherResourceOnCRArgsForCall, struct {
		arg1 v1.Object
	}{arg1})
	fake.recordInvocation("SetChaincodeLauncherResourceOnCR", []interface{}{arg1})
	fake.setChaincodeLauncherResourceOnCRMutex.Unlock()
	if fake.SetChaincodeLauncherResourceOnCRStub != nil {
		return fake.SetChaincodeLauncherResourceOnCRStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setChaincodeLauncherResourceOnCRReturns
	return fakeReturns.result1
}

func (fake *Migrator) SetChaincodeLauncherResourceOnCRCallCount() int {
	fake.setChaincodeLauncherResourceOnCRMutex.RLock()
	defer fake.setChaincodeLauncherResourceOnCRMutex.RUnlock()
	return len(fake.setChaincodeLauncherResourceOnCRArgsForCall)
}

func (fake *Migrator) SetChaincodeLauncherResourceOnCRCalls(stub func(v1.Object) error) {
	fake.setChaincodeLauncherResourceOnCRMutex.Lock()
	defer fake.setChaincodeLauncherResourceOnCRMutex.Unlock()
	fake.SetChaincodeLauncherResourceOnCRStub = stub
}

func (fake *Migrator) SetChaincodeLauncherResourceOnCRArgsForCall(i int) v1.Object {
	fake.setChaincodeLauncherResourceOnCRMutex.RLock()
	defer fake.setChaincodeLauncherResourceOnCRMutex.RUnlock()
	argsForCall := fake.setChaincodeLauncherResourceOnCRArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Migrator) SetChaincodeLauncherResourceOnCRReturns(result1 error) {
	fake.setChaincodeLauncherResourceOnCRMutex.Lock()
	defer fake.setChaincodeLauncherResourceOnCRMutex.Unlock()
	fake.SetChaincodeLauncherResourceOnCRStub = nil
	fake.setChaincodeLauncherResourceOnCRReturns = struct {
		result1 error
	}{result1}
}

func (fake *Migrator) SetChaincodeLauncherResourceOnCRReturnsOnCall(i int, result1 error) {
	fake.setChaincodeLauncherResourceOnCRMutex.Lock()
	defer fake.setChaincodeLauncherResourceOnCRMutex.Unlock()
	fake.SetChaincodeLauncherResourceOnCRStub = nil
	if fake.setChaincodeLauncherResourceOnCRReturnsOnCall == nil {
		fake.setChaincodeLauncherResourceOnCRReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setChaincodeLauncherResourceOnCRReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Migrator) UpdateConfig(arg1 v1.Object, arg2 string) error {
	fake.updateConfigMutex.Lock()
	ret, specificReturn := fake.updateConfigReturnsOnCall[len(fake.updateConfigArgsForCall)]
	fake.updateConfigArgsForCall = append(fake.updateConfigArgsForCall, struct {
		arg1 v1.Object
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("UpdateConfig", []interface{}{arg1, arg2})
	fake.updateConfigMutex.Unlock()
	if fake.UpdateConfigStub != nil {
		return fake.UpdateConfigStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateConfigReturns
	return fakeReturns.result1
}

func (fake *Migrator) UpdateConfigCallCount() int {
	fake.updateConfigMutex.RLock()
	defer fake.updateConfigMutex.RUnlock()
	return len(fake.updateConfigArgsForCall)
}

func (fake *Migrator) UpdateConfigCalls(stub func(v1.Object, string) error) {
	fake.updateConfigMutex.Lock()
	defer fake.updateConfigMutex.Unlock()
	fake.UpdateConfigStub = stub
}

func (fake *Migrator) UpdateConfigArgsForCall(i int) (v1.Object, string) {
	fake.updateConfigMutex.RLock()
	defer fake.updateConfigMutex.RUnlock()
	argsForCall := fake.updateConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Migrator) UpdateConfigReturns(result1 error) {
	fake.updateConfigMutex.Lock()
	defer fake.updateConfigMutex.Unlock()
	fake.UpdateConfigStub = nil
	fake.updateConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *Migrator) UpdateConfigReturnsOnCall(i int, result1 error) {
	fake.updateConfigMutex.Lock()
	defer fake.updateConfigMutex.Unlock()
	fake.UpdateConfigStub = nil
	if fake.updateConfigReturnsOnCall == nil {
		fake.updateConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Migrator) UpgradeDBs(arg1 v1.Object, arg2 operatorconfig.DBMigrationTimeouts) error {
	fake.upgradeDBsMutex.Lock()
	ret, specificReturn := fake.upgradeDBsReturnsOnCall[len(fake.upgradeDBsArgsForCall)]
	fake.upgradeDBsArgsForCall = append(fake.upgradeDBsArgsForCall, struct {
		arg1 v1.Object
		arg2 operatorconfig.DBMigrationTimeouts
	}{arg1, arg2})
	fake.recordInvocation("UpgradeDBs", []interface{}{arg1, arg2})
	fake.upgradeDBsMutex.Unlock()
	if fake.UpgradeDBsStub != nil {
		return fake.UpgradeDBsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.upgradeDBsReturns
	return fakeReturns.result1
}

func (fake *Migrator) UpgradeDBsCallCount() int {
	fake.upgradeDBsMutex.RLock()
	defer fake.upgradeDBsMutex.RUnlock()
	return len(fake.upgradeDBsArgsForCall)
}

func (fake *Migrator) UpgradeDBsCalls(stub func(v1.Object, operatorconfig.DBMigrationTimeouts) error) {
	fake.upgradeDBsMutex.Lock()
	defer fake.upgradeDBsMutex.Unlock()
	fake.UpgradeDBsStub = stub
}

func (fake *Migrator) UpgradeDBsArgsForCall(i int) (v1.Object, operatorconfig.DBMigrationTimeouts) {
	fake.upgradeDBsMutex.RLock()
	defer fake.upgradeDBsMutex.RUnlock()
	argsForCall := fake.upgradeDBsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Migrator) UpgradeDBsReturns(result1 error) {
	fake.upgradeDBsMutex.Lock()
	defer fake.upgradeDBsMutex.Unlock()
	fake.UpgradeDBsStub = nil
	fake.upgradeDBsReturns = struct {
		result1 error
	}{result1}
}

func (fake *Migrator) UpgradeDBsReturnsOnCall(i int, result1 error) {
	fake.upgradeDBsMutex.Lock()
	defer fake.upgradeDBsMutex.Unlock()
	fake.UpgradeDBsStub = nil
	if fake.upgradeDBsReturnsOnCall == nil {
		fake.upgradeDBsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upgradeDBsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Migrator) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.migrationNeededMutex.RLock()
	defer fake.migrationNeededMutex.RUnlock()
	fake.setChaincodeLauncherResourceOnCRMutex.RLock()
	defer fake.setChaincodeLauncherResourceOnCRMutex.RUnlock()
	fake.updateConfigMutex.RLock()
	defer fake.updateConfigMutex.RUnlock()
	fake.upgradeDBsMutex.RLock()
	defer fake.upgradeDBsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Migrator) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ fabric.Migrator = new(Migrator)
