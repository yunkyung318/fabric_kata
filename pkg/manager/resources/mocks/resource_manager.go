// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/IBM-Blockchain/fabric-operator/pkg/manager/resources"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type ResourceManager struct {
	CheckStateStub        func(v1.Object) error
	checkStateMutex       sync.RWMutex
	checkStateArgsForCall []struct {
		arg1 v1.Object
	}
	checkStateReturns struct {
		result1 error
	}
	checkStateReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStub        func(v1.Object) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 v1.Object
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	ExistsStub        func(v1.Object) bool
	existsMutex       sync.RWMutex
	existsArgsForCall []struct {
		arg1 v1.Object
	}
	existsReturns struct {
		result1 bool
	}
	existsReturnsOnCall map[int]struct {
		result1 bool
	}
	GetStub        func(v1.Object) (client.Object, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 v1.Object
	}
	getReturns struct {
		result1 client.Object
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 client.Object
		result2 error
	}
	GetNameStub        func(v1.Object) string
	getNameMutex       sync.RWMutex
	getNameArgsForCall []struct {
		arg1 v1.Object
	}
	getNameReturns struct {
		result1 string
	}
	getNameReturnsOnCall map[int]struct {
		result1 string
	}
	ReconcileStub        func(v1.Object, bool) error
	reconcileMutex       sync.RWMutex
	reconcileArgsForCall []struct {
		arg1 v1.Object
		arg2 bool
	}
	reconcileReturns struct {
		result1 error
	}
	reconcileReturnsOnCall map[int]struct {
		result1 error
	}
	RestoreStateStub        func(v1.Object) error
	restoreStateMutex       sync.RWMutex
	restoreStateArgsForCall []struct {
		arg1 v1.Object
	}
	restoreStateReturns struct {
		result1 error
	}
	restoreStateReturnsOnCall map[int]struct {
		result1 error
	}
	SetCustomNameStub        func(string)
	setCustomNameMutex       sync.RWMutex
	setCustomNameArgsForCall []struct {
		arg1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *ResourceManager) CheckState(arg1 v1.Object) error {
	fake.checkStateMutex.Lock()
	ret, specificReturn := fake.checkStateReturnsOnCall[len(fake.checkStateArgsForCall)]
	fake.checkStateArgsForCall = append(fake.checkStateArgsForCall, struct {
		arg1 v1.Object
	}{arg1})
	fake.recordInvocation("CheckState", []interface{}{arg1})
	fake.checkStateMutex.Unlock()
	if fake.CheckStateStub != nil {
		return fake.CheckStateStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.checkStateReturns
	return fakeReturns.result1
}

func (fake *ResourceManager) CheckStateCallCount() int {
	fake.checkStateMutex.RLock()
	defer fake.checkStateMutex.RUnlock()
	return len(fake.checkStateArgsForCall)
}

func (fake *ResourceManager) CheckStateCalls(stub func(v1.Object) error) {
	fake.checkStateMutex.Lock()
	defer fake.checkStateMutex.Unlock()
	fake.CheckStateStub = stub
}

func (fake *ResourceManager) CheckStateArgsForCall(i int) v1.Object {
	fake.checkStateMutex.RLock()
	defer fake.checkStateMutex.RUnlock()
	argsForCall := fake.checkStateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ResourceManager) CheckStateReturns(result1 error) {
	fake.checkStateMutex.Lock()
	defer fake.checkStateMutex.Unlock()
	fake.CheckStateStub = nil
	fake.checkStateReturns = struct {
		result1 error
	}{result1}
}

func (fake *ResourceManager) CheckStateReturnsOnCall(i int, result1 error) {
	fake.checkStateMutex.Lock()
	defer fake.checkStateMutex.Unlock()
	fake.CheckStateStub = nil
	if fake.checkStateReturnsOnCall == nil {
		fake.checkStateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkStateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ResourceManager) Delete(arg1 v1.Object) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 v1.Object
	}{arg1})
	fake.recordInvocation("Delete", []interface{}{arg1})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteReturns
	return fakeReturns.result1
}

func (fake *ResourceManager) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *ResourceManager) DeleteCalls(stub func(v1.Object) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *ResourceManager) DeleteArgsForCall(i int) v1.Object {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ResourceManager) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *ResourceManager) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ResourceManager) Exists(arg1 v1.Object) bool {
	fake.existsMutex.Lock()
	ret, specificReturn := fake.existsReturnsOnCall[len(fake.existsArgsForCall)]
	fake.existsArgsForCall = append(fake.existsArgsForCall, struct {
		arg1 v1.Object
	}{arg1})
	fake.recordInvocation("Exists", []interface{}{arg1})
	fake.existsMutex.Unlock()
	if fake.ExistsStub != nil {
		return fake.ExistsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.existsReturns
	return fakeReturns.result1
}

func (fake *ResourceManager) ExistsCallCount() int {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	return len(fake.existsArgsForCall)
}

func (fake *ResourceManager) ExistsCalls(stub func(v1.Object) bool) {
	fake.existsMutex.Lock()
	defer fake.existsMutex.Unlock()
	fake.ExistsStub = stub
}

func (fake *ResourceManager) ExistsArgsForCall(i int) v1.Object {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	argsForCall := fake.existsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ResourceManager) ExistsReturns(result1 bool) {
	fake.existsMutex.Lock()
	defer fake.existsMutex.Unlock()
	fake.ExistsStub = nil
	fake.existsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *ResourceManager) ExistsReturnsOnCall(i int, result1 bool) {
	fake.existsMutex.Lock()
	defer fake.existsMutex.Unlock()
	fake.ExistsStub = nil
	if fake.existsReturnsOnCall == nil {
		fake.existsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.existsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *ResourceManager) Get(arg1 v1.Object) (client.Object, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 v1.Object
	}{arg1})
	fake.recordInvocation("Get", []interface{}{arg1})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ResourceManager) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *ResourceManager) GetCalls(stub func(v1.Object) (client.Object, error)) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *ResourceManager) GetArgsForCall(i int) v1.Object {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ResourceManager) GetReturns(result1 client.Object, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 client.Object
		result2 error
	}{result1, result2}
}

func (fake *ResourceManager) GetReturnsOnCall(i int, result1 client.Object, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 client.Object
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 client.Object
		result2 error
	}{result1, result2}
}

func (fake *ResourceManager) GetName(arg1 v1.Object) string {
	fake.getNameMutex.Lock()
	ret, specificReturn := fake.getNameReturnsOnCall[len(fake.getNameArgsForCall)]
	fake.getNameArgsForCall = append(fake.getNameArgsForCall, struct {
		arg1 v1.Object
	}{arg1})
	fake.recordInvocation("GetName", []interface{}{arg1})
	fake.getNameMutex.Unlock()
	if fake.GetNameStub != nil {
		return fake.GetNameStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getNameReturns
	return fakeReturns.result1
}

func (fake *ResourceManager) GetNameCallCount() int {
	fake.getNameMutex.RLock()
	defer fake.getNameMutex.RUnlock()
	return len(fake.getNameArgsForCall)
}

func (fake *ResourceManager) GetNameCalls(stub func(v1.Object) string) {
	fake.getNameMutex.Lock()
	defer fake.getNameMutex.Unlock()
	fake.GetNameStub = stub
}

func (fake *ResourceManager) GetNameArgsForCall(i int) v1.Object {
	fake.getNameMutex.RLock()
	defer fake.getNameMutex.RUnlock()
	argsForCall := fake.getNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ResourceManager) GetNameReturns(result1 string) {
	fake.getNameMutex.Lock()
	defer fake.getNameMutex.Unlock()
	fake.GetNameStub = nil
	fake.getNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *ResourceManager) GetNameReturnsOnCall(i int, result1 string) {
	fake.getNameMutex.Lock()
	defer fake.getNameMutex.Unlock()
	fake.GetNameStub = nil
	if fake.getNameReturnsOnCall == nil {
		fake.getNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *ResourceManager) Reconcile(arg1 v1.Object, arg2 bool) error {
	fake.reconcileMutex.Lock()
	ret, specificReturn := fake.reconcileReturnsOnCall[len(fake.reconcileArgsForCall)]
	fake.reconcileArgsForCall = append(fake.reconcileArgsForCall, struct {
		arg1 v1.Object
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("Reconcile", []interface{}{arg1, arg2})
	fake.reconcileMutex.Unlock()
	if fake.ReconcileStub != nil {
		return fake.ReconcileStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.reconcileReturns
	return fakeReturns.result1
}

func (fake *ResourceManager) ReconcileCallCount() int {
	fake.reconcileMutex.RLock()
	defer fake.reconcileMutex.RUnlock()
	return len(fake.reconcileArgsForCall)
}

func (fake *ResourceManager) ReconcileCalls(stub func(v1.Object, bool) error) {
	fake.reconcileMutex.Lock()
	defer fake.reconcileMutex.Unlock()
	fake.ReconcileStub = stub
}

func (fake *ResourceManager) ReconcileArgsForCall(i int) (v1.Object, bool) {
	fake.reconcileMutex.RLock()
	defer fake.reconcileMutex.RUnlock()
	argsForCall := fake.reconcileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *ResourceManager) ReconcileReturns(result1 error) {
	fake.reconcileMutex.Lock()
	defer fake.reconcileMutex.Unlock()
	fake.ReconcileStub = nil
	fake.reconcileReturns = struct {
		result1 error
	}{result1}
}

func (fake *ResourceManager) ReconcileReturnsOnCall(i int, result1 error) {
	fake.reconcileMutex.Lock()
	defer fake.reconcileMutex.Unlock()
	fake.ReconcileStub = nil
	if fake.reconcileReturnsOnCall == nil {
		fake.reconcileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.reconcileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ResourceManager) RestoreState(arg1 v1.Object) error {
	fake.restoreStateMutex.Lock()
	ret, specificReturn := fake.restoreStateReturnsOnCall[len(fake.restoreStateArgsForCall)]
	fake.restoreStateArgsForCall = append(fake.restoreStateArgsForCall, struct {
		arg1 v1.Object
	}{arg1})
	fake.recordInvocation("RestoreState", []interface{}{arg1})
	fake.restoreStateMutex.Unlock()
	if fake.RestoreStateStub != nil {
		return fake.RestoreStateStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.restoreStateReturns
	return fakeReturns.result1
}

func (fake *ResourceManager) RestoreStateCallCount() int {
	fake.restoreStateMutex.RLock()
	defer fake.restoreStateMutex.RUnlock()
	return len(fake.restoreStateArgsForCall)
}

func (fake *ResourceManager) RestoreStateCalls(stub func(v1.Object) error) {
	fake.restoreStateMutex.Lock()
	defer fake.restoreStateMutex.Unlock()
	fake.RestoreStateStub = stub
}

func (fake *ResourceManager) RestoreStateArgsForCall(i int) v1.Object {
	fake.restoreStateMutex.RLock()
	defer fake.restoreStateMutex.RUnlock()
	argsForCall := fake.restoreStateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ResourceManager) RestoreStateReturns(result1 error) {
	fake.restoreStateMutex.Lock()
	defer fake.restoreStateMutex.Unlock()
	fake.RestoreStateStub = nil
	fake.restoreStateReturns = struct {
		result1 error
	}{result1}
}

func (fake *ResourceManager) RestoreStateReturnsOnCall(i int, result1 error) {
	fake.restoreStateMutex.Lock()
	defer fake.restoreStateMutex.Unlock()
	fake.RestoreStateStub = nil
	if fake.restoreStateReturnsOnCall == nil {
		fake.restoreStateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.restoreStateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ResourceManager) SetCustomName(arg1 string) {
	fake.setCustomNameMutex.Lock()
	fake.setCustomNameArgsForCall = append(fake.setCustomNameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SetCustomName", []interface{}{arg1})
	fake.setCustomNameMutex.Unlock()
	if fake.SetCustomNameStub != nil {
		fake.SetCustomNameStub(arg1)
	}
}

func (fake *ResourceManager) SetCustomNameCallCount() int {
	fake.setCustomNameMutex.RLock()
	defer fake.setCustomNameMutex.RUnlock()
	return len(fake.setCustomNameArgsForCall)
}

func (fake *ResourceManager) SetCustomNameCalls(stub func(string)) {
	fake.setCustomNameMutex.Lock()
	defer fake.setCustomNameMutex.Unlock()
	fake.SetCustomNameStub = stub
}

func (fake *ResourceManager) SetCustomNameArgsForCall(i int) string {
	fake.setCustomNameMutex.RLock()
	defer fake.setCustomNameMutex.RUnlock()
	argsForCall := fake.setCustomNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ResourceManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.checkStateMutex.RLock()
	defer fake.checkStateMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.getNameMutex.RLock()
	defer fake.getNameMutex.RUnlock()
	fake.reconcileMutex.RLock()
	defer fake.reconcileMutex.RUnlock()
	fake.restoreStateMutex.RLock()
	defer fake.restoreStateMutex.RUnlock()
	fake.setCustomNameMutex.RLock()
	defer fake.setCustomNameMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *ResourceManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ resources.Manager = new(ResourceManager)
